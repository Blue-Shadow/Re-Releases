#include "zcommon.acs"
#library "strnghld"

str mapinfo[56][11] =
{
	{
		"Training Mission","Mars","Introduction","Deadline (Intro)","4","none","P_STR01",
		"Welcome to the training course. Here you will be pitted against hologrammatic",
		"renditions of the Hell's weakest minions to get a taste of what awaits on the",
		"real battlefields. Don't be afraid, the holo-demons aren't able to harm you.",
		"Lt. Carmack will give you further briefing on the premise of deadline defense."
	},
	{
		"Tier 1, Mission 1","Mars","Too Young to Defend","Deadline","10","$100","P_STR02",
		"This will be your first major stronghold defense mission, marine. Here",
		"you'll encounter the weakest of hell's forces, but that doesn't mean you",
		"won't still have to be on your toes at all times - the difficulty mounts",
		"rapidly, so put all you've learned in training to the test!"
	},
	{
		"Tier 1, Mission 2","Sigma Two","Swamp","Deadline","10","$200","P_STR03",
		"The acidic lakes surrounding the perimeter of our strongholds on this planet are",
		"bathing holes for demons. Expect the demon numbers to be high and the task of",
		"successfully defending this stronghold to be taxing for the amateur defender.",
		"And be sure not to plummet into the acid."
	},
	{
		"Tier 1, Mission 3","Maelstrom","Asteroid","Deadline","10","$300","P_STR04",
		"This volatile nebula houses a single UAC stronghold. Even so, it's a crucial research",
		"outpost, and its scientists wish to study the unique phenomena that occur within",
		"this maelstrom. Research that could revolutionize UAC gateway technology is being",
		"conducted here, so it is vital that this facility doesn't fall to the legions of Hell."
	},
	{
		"Tier 1, Mission 4","Crimson","Twilight","Deadline","10","$400","P_STR05",
		"This dark mountain peak is home to a minute UAC stronghold. Demons are approaching from",
		"the planet's ground level from all directions, and aerial assaults from steadily growing",
		"demonic swarms are to be expected. It will be easy to let even the weakest demon cross the",
		"deadline, so you'll have to secure the stronghold entrance as tightly as possible."
	},
	{
		"Tier 1, Mission 5","Earth","Downtown","Core (Intro)","10","$500","P_STR06",
		"Our beloved homeworld is rarely safe from demon invasion, especially one on a galactic",
		"scale. Possessed humans, now slaves to the demonic empire of Hell, roam our streets,",
		"laying out a swath of destruction, while Hell sends out its heavy militia towards a",
		"crucial UAC control point - a computer core station. Defend it with your life!"
	},
	{
		"Tier 2, Mission 1","Null X-1","Sandstorm","Core","10","$600","P_STR07",
		"This barren planet seems to be devoid of any humanoid life, hence the name. Even so, the",
		"demons have chosen to wage an attack on a recently abandoned core facility which, as it",
		"turns out, may prove useful in future UAC endeavors after all. Restore hope to this",
		"forsaken planet and protect the computer core at all costs!"
	},
	{
		"Tier 2, Mission 2","Gorge","Tropical Paradox","Core","10","$700","P_STR08",
		"What was once an island paradise is now a demon-infested hellhole. This planet was",
		"a widely-famed holiday resort for intergalactic tourists, at least before the demons",
		"landed. Expect heavy resistance to come from all directions towards your stronghold.",
		""
	},
	{
		"Tier 2, Mission 3","Herros","Volcanic Installation","Core","3","$800","P_STR09",
		"This storage facility is situated in extremely hostile territory. Swarms of hellspawn",
		"are approaching, and the hazardous lava-filled caverns make for demon breeding",
		"grounds. Defending this stronghold will be a tricky undertaking, and be prepared",
		"for the worst, whatever that might be."
	},
	{
		"Tier 2, Mission 4","Cyclone","Skyfire Research","Core","10","$900","P_STR10",
		"This research substation, orbiting the planet Cyclone, is one of many that links",
		"to the main orbital research nexus, also in orbit over the planet. If the demons ",
		"succeed in severing this vital connection, the UAC research network may suffer a",
		"crippling blow. Be sure to use the station's defensive ion cannon to your advantage."
	},
	{
		"Tier 2, Mission 5","Scorpid","Tunnel","Milestone (Intro)","10","$1000","P_STR11",
		"This stronghold is a truly massive structure, one of the UAC's finest, so it's",
		"expected that the demons will be attacking it in equally monstrous waves. You",
		"will have to change your tactics somewhat to ensure the complete security of",
		"this stronghold. See Lt. Carmack for further briefing."
	},
	{
		"Tier 3, Mission 1","Skorpid","Dangoo Desert","Deadline","10","$1100","P_STR12",
		"A planet as dry and barren as the Sahara, although the demons seem to relish in such",
		"conditions. They are advancing on this tiny stronghold in large numbers, and seek",
		"its immediate destruction. A hazardous task is ahead of you, but you as a marine",
		"are expected to serve the UAC by defending it with your life!"
	},
	{
		"Tier 3, Mission 2","Maelstrom","Inferno","Deadline","10","$1200","P_STR13",
		"Deep within the underground caverns of this fiery asteroid, all hell is quite",
		"literally breaking loose. This is not so much a stronghold as simply a very large",
		"mining excavation, where we have uncovered the remains of a hellish temple. Quite",
		"obviously, the demon swarms will be flourishing here, so stay totally sharp."
	},
	{
		"Tier 3, Mission 3","Ormantium","Orbit","Deadline","10","$1300","P_STR14",
		"This space station in high orbit over the planet Ormantium is under attack from",
		"heavily-armed demon/cyborg onslaughts. Such invaders require heavy-duty weaponry",
		"to take down, so you'll be provided with plenty of rockets for most of this mission.",
		"You may, however, also require a certain amount of luck to get through unscathed..."
	},
	{
		"Tier 3, Mission 4","Styx","Armageddon","Core","10","$1400","P_STR15",
		"On this chaotic planet, where fire rains from the constantly stormy sky,",
		"demons from the foulest of Hell's pits are trying to overrun a vital computer",
		"station situated on a charred, rocky ridge. The conditions are hostile and the",
		"monsters are many, but you must still do your utmost to hold them back!"
	},
	{
		"Tier 3, Mission 5","Cerberus","Frozen","Limit (Intro)","7","$1500","P_STR16",
		"This bitterly cold planet houses a vast, powerful UAC stronghold. It could stand",
		"a large scale assault from the demonic army of Hell, at least for a while, but",
		"the massive waves of monsters advancing still pose a threat. This mission will",
		"test your mettle for crowd control to the limit - literally."
	},
	{
		"Tier 4, Mission 1","Sigma Two","Slaughtered","Core","10","$1600","P_STR17",
		"The dismal planet of Sigma Two is not one of the most preferable locales for a",
		"considerably-sized defense stronghold such as this one, but unfortunately the demon",
		"waves approaching it are sufficient enough in number to level it completely. We",
		"can't suffer a loss that great, so it's up to you to make this mission a success."
	},
	{
		"Tier 4, Mission 2","Crimson","Smoldering Caves","Limit","10","$1700","P_STR18",
		"An abandoned defense bunker that was utterly stormed during the last demon invasion.",
		"Some of its defensive utilities are still intact, though you won't have many places",
		"to hide, and even fewer chances to hold the advancing waves back. Do all you can under",
		"the circumstances to stop the hellspawn from destroying it!"
	},
	{
		"Tier 4, Mission 3","Styx","Tarstone Fortress","Limit","10","$1800","P_STR19",
		"This demonic edifice houses a gateway leading directly to our supercluster. Many",
		"brave soldiers have lost their lives trying to stabilize this sector, but despite",
		"their efforts, hordes of demons are still trying to take back the gateway. They will",
		"wreak havoc upon our homeworlds if we lose control of it. It's all up to you."
	},
	{
		"Tier 4, Mission 4","Crimson","Dusk","Deadline","10","$1900","P_STR20",
		"This planet has been renowned amongst UAC explorers and researchers for having many",
		"paradoxical phenomena. It boasts several somewhat peculiar structures, including this",
		"floating fortress, which the UAC is beginning to study in greater depth. However,",
		"the area is already rife with demons, so expect the unexpected."
	},
	{
		"Tier 4, Mission 5","Midnat II","Overmind","Overmind (Intro)","10","$2000","P_STR21",
		"This cold planet, lit only by the spooky aura of its moons, has already been",
		"overrun by the legions of Hell. An enormous, demonic lifeform has been reported",
		"causing untold chaos on our main control tower stronghold here - so in order to",
		"survive, you may have to drastically change your strategies."
	},
	{
		"Tier 5, Mission 1","Rouger","Locus of Pestilence","Deadline","10","$2100","P_STR22",
		"This planet is embraced by an elusive orange fog. A small stronghold has been",
		"constructed here to allow further study of the various other environmental",
		"oddities of this planet. The demons will be arriving to invade every nook and",
		"cranny of this stronghold - so be alert."
	},
	{
		"Tier 5, Mission 2","Chlorine","Bipolar Bunker","Milestone","10","$2200","P_STR23",
		"This is another massive UAC stronghold, constructed within the acidic mines of the",
		"planet Chlorine. There are many vital control points inside the stronghold itself,",
		"and if the invaders manage to take out all of them, the facility is as good as dead.",
		"Beware though, the monsters are fast and powerful, so use everything at your disposal."
	},
	{
		"Tier 5, Mission 3","Midnat II","Aurora Emitter","Limit","10","$2300","P_STR24",
		"This power facility's energy conductors project beautiful lights into the atmosphere",
		"that illuminate the surrounding area. Unfortunately the intense lights have attracted",
		"the attention of the more powerful legions of Hell. Expect heavy resistance from all",
		"sides, and guard the exposed main teleporter at any cost!"
	},
	{
		"Tier 5, Mission 4","Mars","Eye of the Storm","Overmind","10","$2400","P_STR25",
		"The demons are planning an assault on a major Martian defense installation, which",
		"houses a powerful electromagnetic jammer, designed to prevent demons from storming",
		"the planet's surface. The Overmind has been reincarnated not far from this stronghold",
		"with intent to destroy its exterior core network - it must be kept intact!"
	},
	{
		"Tier 5, Mission 5","Deep Space","Deepspace 12","Goals (Intro)","7","$2500","P_STR26",
		"This substantial space station is the hub of the UAC's inter-planetary research network.",
		"Its massive data terminals house crucial information on all of the military branches",
		"and strongholds in this sector. Exabytes of precious data is at stake. Protect every",
		"single square inch of this station, or all will be lost."
	},
	{
		"Tier 6, Mission 1","Cyclone","Cyclone","Milestone","10","$2600","P_STR27",
		"The skies of this elusive planet are constantly dancing with the aurora borealis",
		"phenomenon, as it is known on Earth, and luminous crystals dot the landscape.",
		"This planet is falling rapidly under the demons' influence - and what would",
		"otherwise be a visually bountiful planet is turning into a satanic cesspool."
	},
	{
		"Tier 6, Mission 2","Skorpid","Terrorforming","Goals","7","$2700","P_STR28",
		"Our terraforming station on this planet is being surrounded on all sides by demon",
		"invaders. In the wrong hands, the experimental terraformer device could cause",
		"irreversible damage. You must defend it, AND keep it stable, to prevent the demons",
		"from wresting control of the entire planet."
	},
	{
		"Tier 6, Mission 3","Jailba","Emerald Skies","Limit","11","$2800","P_STR29",
		"This stronghold is situated in a floodplain on the planet Jailba. The arrival of the",
		"demons to this site has caused some massive atmospheric disturbances, so the weather",
		"conditions have harshened dramatically and all personnel have evacuated before the",
		"inevitable flood strikes. The demons will be numerous this time, so gear up well."
	},
	{
		"Tier 6, Mission 4","Deep Space","Convulsion of Nature","Limit","7","$2900","P_STR30",
		"Somehow, on this immense asteroid, the demons have unearthed a dimensional slipgate",
		"that will allow them to jump lightyears at a time. If they are allowed to rampage all",
		"across the universe, then humanity will surely be doomed. Be prepared for the worst,",
		"marine, and block their entrance through the gate through any means necessary!"
	},
	{
		"Tier 6, Mission 5","Null X-1","Black Gold","Core","10","$3000","P_STR31",
		"Welcome back to this barren wasteland of a planet, marine. This time our oil-mining",
		"stronghold has been placed in jeopardy by the spawning hordes of monsters. The core",
		"powering the heavy mining machinery, which if destroyed could render the entire",
		"facility useless, is unfortunately badly exposed. You must not fail us here."
	},
	{
		"Tier 6, Mission 6","Heloxyd","Snake Corridors","Limit","7","$3100","P_STR32",
		"This dilapidated UAC warehouse was abandoned a while ago when deadly toxins from",
		"the planet's underground began seeping into it. While the toxins were eventually",
		"contained, the same can't be said for the hordes of fast, deadly demons that",
		"endanger this stronghold. Defending this base sure won't be a walk in the park."
	},
	{
		"Tier 6, Mission 7","Photon","Antlion Nebula","Milestone","10","$3200","P_STR33",
		"The thick purple fog engulfing the UAC control point in this nebula will only hinder",
		"you, so we've provided you with a few extra temporary means of defense that may aid you",
		"in holding off the demonic army, while you attempt to navigate the complex structure of",
		"this stronghold. We wish you luck - this will by no means be an easy task."
	},
	{
		"Tier 6, Mission 8","Rouger","Three Ways to Die","Core","10","$3300","P_STR34",
		"This planet's thin atmosphere and dangerous proximity to its lethally radioactive",
		"sun make it a hazardous environment. Storms rage violently across its surface,",
		"and a hefty battalion of demons encroaches a series of control towers situated in",
		"a particularly hostile area of the planet. Use caution, there's more than one way to die..."
	},
	{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},
	{
		"Secret Mission 1","Earth","Duke it Out","Save the Babes","10","$1500","P_STR50",
		"An alien invasion is taking place on Earth, but not one like any we've seen before.",
		"The merciless rigelatins have invaded the streets of Los Angeles, destroying",
		"the city, converting its population into monstrous abominations and abducting",
		"our babes. It's time to nuke those sons-of-bitches hard."
	},
	{},
	{
		"Secret Mission 2","Earth","City of Silence: Apocalypse","Limit","10","$1500","P_STR52",
		"All hell has broken loose. The dead rise, the sky falls, and twisted, satanic",
		"magicks are abundant. Worse still, nightmarish ghouls rampage through our towns,",
		"their demented influence corrupting the very fabric of our world. Doomsday is at",
		"hand, and your speed and wile will be tested to the limit."
	},
	{},
	{
		"Secret Mission 3","Hell","Fortress of Damnation","Goals","10","$1500","P_STR54",
		"While hellspawn rampaged on Earth, the UAC launched their remaining task force against",
		"the final demon gate in a bid to close it from the other side. One brave marine stood",
		"up, and overthrew the hellish legions single-handedly. In a recreation of this",
		"historic battle, your misssion is to seal the gate, and secure the control points."
	},
	{},
	{
		"Secret Mission 4","Phobos","Phobos Anomaly","Core","10","$1500","P_STR56",
		"The mining facilities on Phobos revealed this huge, ancient stargate under the moon's",
		"surface. Just after your arrival, the gate opened and let loose hundreds of demons and",
		"zombies. Your task here is to defend the interior of the mining base from this somewhat",
		"familiar onslaught. Will you succeed where your predecessors failed?"
	},
};

str MonsterNames[42] =
{
	"Former Human",
	"Former Human Sergeant",
	"Former Human Commando",
	"Former Human Rocketeer",
	"Dune Warrior",
	"Suicide Bomber",
	"Zombie Tank",
	//
	"Imp",
	"Phase Imp",
	"Shadow",
	"Catharsi",
	//
	"Bull Demon (aka pinky)",
	"Mech Demon / Blood Demon",
	"Nightmare Demon",
	//
	"Lost Soul",
	"Guardian Cube",
	"Hades Sphere",
	"Wicked",
	//
	"Cacodemon",
	"Enhanced Cacodemon",
	"Pain Elemental",
	"Hades Elemental",
	//
	"Revenant",
	//
	"Hell Knight",
	"Baron of Hell",
	"Hell Warrior",
	"Bruiser Demon",
	"Cyber Baron / Cybruiser",
	"Archon of Hell",
	"Azazel",
	"Pyro Demon",
	//
	"Mancubus",
	"Hectebus",
	//
	"Arachnotron",
	"Fusion Cannon Arachnotron",
	//
	"Hellion",
	"Arch-vile",
	"Diabloist",
	//
	"Spider Mastermind",
	"Spider Demolisher",
	"Cyberdemon",
	"Terminator",
};

// \ce brown <=50Very Low
// \ch blue <=100Low
// \cd green <=300Medium
// \cf gold <=500Medium High
// \ci orange <=1000High
// \cg red >1000Very High
// \ca brick >3000Insane

str MonsterStats[42][9] =
{
	{"HoloDeco_Zombieman","\cu20","\chSlow","\cuVery Low","Undead","Hitscan","$1-3","None","S. Priestess"},
	{"HoloDeco_Shotgunguy","\cu30","\chSlow","\chLow","Undead","Hitscan","$2-4","None","S. Priestess"},
	{"HoloDeco_Chaingunner","\ch60","\chSlow","\cdMedium","Undead","Hitscan (Continuous)","$5-8","None","S. Priestess"},
	{"HoloDeco_RocketTrooper","\cu50","\chSlow","\cdMedium","Undead","Projectile","$3-5","None","W. Weasel"},
	{"HoloDeco_DuneWarrior","\cu120","\chSlow","\cdMedium","Undead","Projectile and Hitscan","$4-8","Cloak","J. Paddock"},
	{"HoloDeco_SuicideBomber","\ch80","\cgFast","\cdMedium","Undead","Melee Only","$5","Kamikaze","W. Weasel"},
	{"HoloDeco_ZombieTank","\ch600","\cgFast","\cdMedium","Undead/Mechanical","Hitscan (Semi-Continuous)","$8","None","J. Paddock"},
	// 5
	{"HoloDeco_Imp","\ch60","\chSlow","\chLow","Demon","Projectile and Melee","$3-6","None","J. Paddock"},
	{"HoloDeco_PhaseImp","\ch150","\ca???","\cfMedium High","Mutant","Tracer and Melee","$6-9","Phase","J. Paddock"},
	{"HoloDeco_Shadow","\ch80","\cgFast","\cdMedium","Demon","Projectile (Continuous)","$5-8","None","B. V. Ostmann"},
	{"HoloDeco_Catharsi","\ch120","\chSlow","\cdMedium","Alien","Projectile","$7-10","Bomb","W. Weasel"},
	// 9
	{"HoloDeco_Demon","\ch150","\cfQuick","\cdMedium","Demon","Melee Only","$5","None","W. Weasel"},
	{"HoloDeco_BloodDemon","\cd300","\cgFast","\cdMedium","Demon/Cyborg","Melee Only","$8","None","W. Weasel"},
	{"HoloDeco_NightmareDemon","\ch260","\cgFast","\cfMedium High","Demon","Projectile and Melee","$10","Stealth","J. Paddock"},
	// 12
	{"HoloDeco_LostSoul","\ch100","\cgFast","\cdMedium","Demon","Charge","$5","Flight","W. Weasel & S. Priestess"},
	{"HoloDeco_GuardianCube","\ch80","\cfQuick","\cdMedium","Unknown","Projectile","$6","Flight","J. Paddock"},
	{"HoloDeco_HS","\cu35","\cfQuick","\cfMedium High","Unknown","Melee Only","$12","Flight, Phase, Kamikaze","J. Paddock"},
	{"HoloDeco_Wicked","\cd275","\chSlow","\cdMedium","Demon","Projectile","$8","Flight","J. Paddock"},
	// 15
	{"HoloDeco_Cacodemon","\cd400","\chSlow","\cdMedium","Demon","Projectile and Melee","$9","Flight","B. V. Ostmann"},
	{"HoloDeco_EnhancedCaco","\cd300","\chSlow","\cdMedium","Mutant","Projectile and Melee","$10","Flight","W. Weasel"},
	{"HoloDeco_PainElemental","\cd400","\chSlow","\cfMedium High","Demon","Spawn","$10","Flight, Death Spawn","W. Weasel"},
	{"HoloDeco_Helemental","\cg1600","\chSlow","\cdVery High","Demon","\cgOH SHIT","$64","Flight, Phase","J. Paddock"},
	// 19
	{"HoloDeco_Revenant","\cd300","\cfQuick","\cfMedium High","Undead","Projectile, Tracer and Melee","$15","None","S. Priestess"},
	// 20
	{"HoloDeco_HellKnight","\cf500","\chSlow","\cdMedium","Demon","Projectile and Melee","$15","None","S. Priestess"},
	{"HoloDeco_BaronOfHell","\ci1000","\chSlow","\cfMedium High","Demon","Projectile and Melee","$20","None","S. Priestess"},
	{"HoloDeco_HellWarrior","\ci400","\chSlow","\cfMedium High","Demon","Projectile and Melee","$12","Shield","J. Paddock"},
	{"HoloDeco_BruiserDemon","\cg1500","\chSlow","\cgVery High","Demon","Projectile, Floor Hugger","$30","None","W. Weasel"},
	{"HoloDeco_Cybruiser","\cg2000","\chSlow","\cgVery High","Demon","Projectile and Melee","$15","None","W. Weasel"},
	{"HoloDeco_ArchonOfHell","\cg2000","\chSlow","\cgVery High","Demon/Cyborg","Projectile and Melee","$22","None","W. Weasel"},
	{"HoloDeco_Azazel","\cg2400","\chSlow","\caInsane!","Demon","\cgEverything!","$30","None","J. Paddock"},
	{"HoloDeco_PyroDemon","\cg2000","\chSlow","\caInsane!","Demon","\cgEverything!","$40","Teleportation","S. Scream"},
	// 25
	{"HoloDeco_Fatso","\cf600","\chSlow","\cfMedium High","Demon/Cyborg","Projectile","$10","None","W. Weasel"},
	{"HoloDeco_Hectebus","\cg1500","\chSlow","\ciHigh","Demon/Cyborg","Projectile","$16","None","J. Paddock"},
	// 27
	{"HoloDeco_Arachnotron","\cd500","\chSlow","\cfMedium High","Demon/Cyborg","Projectile (Continuous)","$12","None","S. Priestess"},
	{"HoloDeco_FusionSpider","\ci600","\chSlow","\ciHigh","Demon/Cyborg","Projectile (Continuous)","$17","None","J. Paddock"},
	// 29
	{"HoloDeco_Hellion","\ch70","\cfQuick","\cdMedium","Demon","Projectile","$12","None","M. Orpheus"},
	{"HoloDeco_ArchVile","\ci700","\cgFast","\cgVery High","Demon","Distance","$25","Resurrection","S. Priestess"},
	{"HoloDeco_Diabolist","\ci1400","\cgFast","\cgVery High","Demon","Projectile, Tracer, Distance","$20","None","J. Paddock"},
	// 31
	{"HoloDeco_Mastermind","\ca3000","\chSlow","\cfMedium High","Demon/Cyborg","Hitscan (Continuous)","$50","None","W. Weasel"},
	{"HoloDeco_Demolisher","\ca6000","\chSlow","\cgVery High","Demon/Cyborg","Projectile and Hitscan (Continuous)","$75","None","W. Weasel"},
	{"HoloDeco_CyberDemon","\ca4000","\chSlow","\ciHigh","Demon/Cyborg","Projectile","$50","None","S. Priestess"},
	{"HoloDeco_Terminator","\ca4000","\chSlow","\caInsane!","Cyborg","Projectile and Hitscan","$60","None","B. V. Ostmann"},
	// 35
};

str MonsterBio[42][8] =
{
	//---ZOMBIES---//
	//Zombieman
	{
		"The weakest, and most common enemy. All they have is a pistol, and they're",
		"really a poor shot. They're only really a threat in large groups, but even",
		"then they probably cause more collateral damage than they'll do to you. They",
		"don't put up much of a fight if you shoot them down quickly enough.","","","",""
	},
	//Shotgun Guy
	{
		"A step up from the zombieman; this guy wields a shotgun. He is still not too",
		"tough, but he'll get you good if you let your guard down.","","","","","",""
	},
	//Chaingunner
	{
		"Kill from a distance if you can. This guy's weapon will pulverize you in",
		"seconds if you don't have suitable cover. If he's involved in a crossfire, he",
		"will usually win because his attacks are so painful that they cause other",
		"demons to slow down.","","","",""
	},
	//Rocket Zombie
	{
		"These men were once members of our Anti-Tank battalions. They carry the same",
		"kind of rocket launcher as you, and pack a gigantic punch if you're not",
		"careful. While they go down easy - they're only human, after all - it may be",
		"more worthwhile to leave them alive for a while to let them accidentally fire",
		"their weapons at larger monsters.","","",""
	},
	//Dune Warrior
	{
		"These guys were once some of our most elite stealth units, trained to brave",
		"the harshest of climates. Their flame bomb launcher and semi-automatic",
		"machinegun are nothing to get too concerned about, because they also possess a",
		"cloaking device, allowing them to bypass your defense belt virtually unseen",
		"until it wears off. Their Achilles' heel is their low health, so if you suspect",
		"they're around, throw a rocket into an open space and watch any of them nearby",
		"go flying.",""
	},
	//Suicide Bomber
	{
		"A possessed soldier wired up with high explosives. His main goal in life is to",
		"run towards something destructible and then detonate himself. He's rather hard",
		"to miss; his insane screaming is quite loud and you'll probably hear it from a",
		"pretty far distance. Interestingly, though, the souls Hell has chosen to",
		"become Kamikazes were evidently those of people who killed themselves",
		"similarly in their previous life. I guess if they did one thing well, they",
		"could always do it again...",""
	},
	//Zombie Tank
	{
		"The zombies left with enough brain capacity to retain their driving skills you",
		"will see swerving around the battlefield in these well-armored UAC vehicles,",
		"firing the mounted gatling guns in every direction. They can also accelerate to",
		"high speeds and as a result capture the objective with relative ease if you",
		"give them sufficient opportunity. The trick is: don't! Have a suitable weapon",
		"on you and make sure to take them out from a distance - destroying them causes",
		"them to explode in a ball of flame, causing minor damage to everything nearby.",""
	},
	//---IMPS---//
	//Imp
	{
		"Forget little dwarf faeries with pick-axes - the real demon is very different.",
		"Imps are probably Hell's expendable worker drones, with fire-summoning attacks",
		"that aren't terribly powerful but threatening all the same, especially when",
		"they emerge in massive groups, which they often do. Because they're rather",
		"weak, it's easy to take them out with a powerful weapon, so make sure you have",
		"one ready in case they choose to bring a few hundred or so of their buddies",
		"along with them.",""
	},
	//Phase Imp
	{
		"Among the adjectives used to describe the phase imp are: fast, durable,",
		"deadly, and annoying. Phase imps appear to be a sort of mutated form of the",
		"regular imp, and unfortunately more than twice as threatening as their lesser",
		"counterparts. Once you hear that bone-chilling war cry, be sure to terminate",
		"them quickly, if you can; they can take a heavy amount of shots before biting",
		"the dirt. If you don't, they will disappear in front of you, before",
		"teleporting beyond the objective and possibly ending your mission in failure.",
		"Make sure you have cover from their homing attacks, as well."
	},
	//Shadow
	{
		"This sneaky little stalker may appear weak at first, and its relatively low",
		"health seems to back this up. However, its high speed and its semi-transparent",
		"flesh makes this foe a much more serious threat, so stay on the lookout for",
		"them as they can pass a defense line with ease. Facing a single shadow is",
		"a very rare occurence, as they ALWAYS appear in swarms of varying sizes.",
		"", "", ""
	},
	//Catharsi
	{
		"Even extraterrestrial life believes in Hell, or at least a variant of it. The",
		"Catharsi don't appear to be demons themselves, but are certainly operating",
		"under Hell's influence. Their dedication is such that, even when near death,",
		"their only goal is the destruction of those who oppose them - watch out for",
		"the floating detonators that they drop when they die. Skilled marines can use",
		"these to their advantage, though, by killing one Catharsi in a group of other",
		"monsters to soften up the rest of them a bit.",""
	},
	//---DEMONS---//
	//Demon
	{
		"The first relatively serious threat to new marines, the Demon is fast and",
		"powerful, and takes a beating. Presumably the Demon's origins come from the",
		"departed souls of athletes who abused steroids, or perhaps they're the",
		"deformed offspring of Hell's various nobles. Beware their speed; even if they",
		"aren't coming for you, they will almost always be the ones to seize the gates.",
		"Certain variants of these demons appear blurred to human eyes and are hard to",
		"see effectively.",""
	},
	//Blood Demon
	{
		"Also nicknamed the \"Steam Demon\", the Blood Demon's craving for speed has",
		"turned it towards cybernetics. Blood Demons are unique for their bionic legs,",
		"which they use to run very, very quickly. The downside to that is that they",
		"make quite a racket when moving around, so if you happen to lose one, listen",
		"for that signature clanking noise.","","",""
	},
	//Nightmare Demon
	{
		"By the time you've noticed a swarm of Nightmare Demons approaching your",
		"objective, it's usually too late to stop 'em in time. These guys are insanely",
		"fast, and regurgiate plasma balls similar to those hurled by the hell nobles.",
		"Not only that, but they turn semi-invisible when roaming, meaning you'll have",
		"to despatch their numbers within seconds of spotting them. Because they",
		"typically ambush strongholds in swarms, you'll have to have a weapon with a",
		"high destructive capacity to make sure they're taken out with all speed.",""
	},
	//---FLIERS---//
	//Lost Soul
	{
		"Hell's version of that hyper little puppy that never left you alone. When he",
		"charges, he's going to be moving fast, so be ready with that itchy trigger",
		"finger of yours or you're going to have a hell of a time keeping this guy away",
		"from the deadline! However, he's easy to dodge, and only poses a threat in",
		"great numbers. A good tactic is to try to line them up so that when they",
		"attack you, they bump into each other, or a nearby demon.","",""
	},
	//Guardian Cube
	{
		"The Guardian Cube is like a weak lost soul, but still annoying as hell. They",
		"fly straight to their objective, being sure to brush away anything that they",
		"see obscuring their goal. They have ranged attacks, too, which they will",
		"launch constantly if their target is visible. Target immediately, and take",
		"them down fast.","","",""
	},
	//Hades Sphere
	{
		"The hades sphere is not really a demon, more like a ball of sentient bloodlust",
		"that phases in and out of existence to fool its opposition, before appearing",
		"in front of them again and self-destructing with extreme force. You won't",
		"usually see these guys on your missions, so thank Heaven for that, but the",
		"Hades Elemental will vomit these guys out in twos, so if you can get a bead on",
		"them, make it count, before the battlefield is swarmed by the bastards.","",""
	},
	//Wicked
	{
		"This peculiar snake-like apparition is like an especially annoying version of",
		"the cacodemon. He will charge, using his whip-like tail to accelerate towards",
		"his foe, and when within range, launch a homing fireball which will sooner",
		"or later catch up with them. They are tougher than they appear, so be ready to",
		"clash heads with them for lengthy periods if you don't have a suitable weapon.",
		"","",""
	},
	//---GASBALLS---//
	//Cacodemon
	{
		"One of the more common enemies you will face while holding back the demonic",
		"forces. The cacodemon contains a mixture of various noxious gases within its",
		"body, which not only enables it to hover through the air, but also lets it",
		"project ignited balls of gas at its prey. The lack of extremities does not",
		"mean that it is incapable of defending itself in close combat; the razor-sharp",
		"teeth and muscular jaws can and will cut through you in an instant.","",""
	},
	//Enhanced Cacodemon
	{
		"So far as we can tell, these guys are pretty much the same as the Cacodemons",
		"you're used to seeing - helium-filled, projectile-spewing tomatoes. Except",
		"these guys can shoot even more fireballs at once. The good part? They're no",
		"harder to actually put down than your garden-variety Cacodemon. Just, uh,",
		"remember to stay out of their way.","","",""
	},
	//Pain Elemental
	{
		"The Pain Elemental combines the two most irritating things in the world:",
		"missiles, and Lost Souls. This floating head - which bears an odd resemblance",
		"to those other floaty monsters - launches Lost Souls at high speeds. Guard the",
		"base entrance carefully when these are around, because if they manage to shoot",
		"a Lost Soul past your defenses, you're pretty much screwed. Oh, and be careful",
		"where you kill them, too, because they leave behind even more Lost Souls when",
		"they explode.",""
	},
	//Hades Elemental
	{
		"You may well have just met your maker. The Hades Elemental is one of the most",
		"powerful monsters you will encounter, with a deadly arsenal consisting of",
		"lightning attacks, regurgitating Hades Spheres, teleportation, and a mouth so",
		"vast it will swallow anything that happens near it. It takes quite a beating",
		"before exploding in a shower of flaming debris (at which point it will spawn",
		"even more Hades Spheres), so you are urged to ensure that you have an extremely",
		"powerful firearm in your possession before confronting this behemoth.",""
	},
	//Revenant
	{
		"Hell doesn't make waste. Take a dead demon, and strap on some armor and homing",
		"rocket launchers, and you've got this fellow. He also likes to get up close",
		"and personal, so watch out! He's moderately tough to kill.","","","","",""
	},
	//---NOBLES---//
	//Hell Knight
	{
		"A lesser version of the Baron of Hell, this creature's skin is not quite as",
		"flushed, and can only take half the amount of damage as their stronger cousins",
		"before dying. They do, however, attack with the same type of plasma, so",
		"caution is still highly advised against them.","","","",""
	},
	//Baron of Hell
	{
		"This creature has red flushed skin over the top half of his body, and goat",
		"legs on the bottom. The Baron of Hell is not as common as some of the other",
		"enemies, but that makes it no less of a threat. He hurls green plasma balls at",
		"his target which can do moderate to severe damage. He's also pretty tough,",
		"too, and it's going to take more than what it usually takes for other enemies",
		"to put him down.","",""
	},
	//Hell Warrior
	{
		"The Hell Warrior's monstrous visage is the first thing you'll notice. Then",
		"you'll notice the huge metal shield he carries. And if you're not careful you",
		"won't be noticing much more after that. Despite only have 400 hit points",
		"(that's less than a Hell Knight), he's still a formidable adversary. His",
		"shield blasts out flesh-rending energy projectiles, and he can absorb all",
		"damage while the shield is raised in front of him. He has the standard noble",
		"plasma attack, too.",""
	},
	//Bruiserdemon
	{
		"Ordinarily we would advise you to run the hell away from these things, but",
		"considering you're supposed to be defending outposts and not saving your own",
		"skin, that is unfortunately not an option. So our best advice to you is: take",
		"cover! Our science team is busy analyzing the Bruiser's genetic code, so maybe",
		"- just MAYBE - we might have a way for you to fight back against these things!",
		"Until then...well, you're on your own.","",""
	},
	//Cybruiser
	{
		"You probably remember the Amish: those Christian folks from Earth that ignored",
		"technology in favor of simple lives and hard work. Well, after seeing",
		"mechanical monstrosities like this, don't you wish Hell took a few pages from",
		"their book? The Cybruiser basically comes from the same mold as Hell's nobles,",
		"but is enhanced with the latest advances (i.e. whatever they stole from the",
		"last base we lost) in targeting systems and anti-vehicle weaponry. This guy",
		"exemplifies why it's so important to guard the outposts in the first place -",
		"to stop stuff like THIS from happening!"
	},
	//Archon of Hell
	{
		"This guy truly stands out from the rest of the Hell nobles - in more ways than",
		"one. First off, he has an unmistakeable black and red hide and boasts huge",
		"spikes all down his upper body. Secondly, he is able to fire volleys of",
		"devastating green comets that tear through armor and flesh alike. And to top",
		"it all off, he vaporizes in a viscous green cloud upon death. Underneath all",
		"that, though, he'll go down much like the rest of his brethren. Unfortunately",
		"the Archon does take a few more hits to beat, and it's much harder to dodge his",
		"attacks, so you still better have your wits about you when you confront him."
	},
	//Azazel
	{
		"Not much is known about the Azazel, mainly due to our unfortunate observers",
		"getting fried every time they try to gather more tactical information on it.",
		"Your best bet when you see it rear its ugly head is to run like hell in the",
		"other direction. If you're standing too close you'll get caught in the range",
		"of its powerful energy discharge attack and get char-grilled. Unload as much",
		"ammo as possible on it as you run, 'cause it'll be throwing a plethora of",
		"projectiles your way, some of which are nigh-impossible to dodge. Easily one",
		"of the most frustrating demons you'll deal with."
	},
	//Pyrodemon
	{
		"These burning beasts' lust for fire has driven them to utter insanity. They",
		"love to kill their victims in the most pyromanic ways, even by exploding into",
		"a ball of fire and reappearing immediately in front of their target. They pay",
		"no mind to any of their nearby brethren, and fire explosive fireballs in every",
		"direction they possibly can, just to get a chance to see you burn. Never get",
		"too close!","",""
	},
	//---FATSOS---//
	//Mancubus
	{
		"The embodiment of gluttony, one of the seven deadly sins. Basically, the",
		"Mancubus is the hellish reincarnation of that fat kid from school that gorged",
		"himself on Twinkies. And now they've given him a pair of high-powered cannons",
		"to compensate for the fact that he can barely move. All that fat will absorb",
		"most of the damage you do to it, but luckily, he can't really aim very well.","","",""
	},
	//Hectebus
	{
		"The Hectebus can probably best be described as his lower cousin tanked-up on a",
		"substantial amount of illegal substances. A considerable proportion larger",
		"than the Mancubus, this colossus has been known to reduce stronghold defenders",
		"to primordial slime in an eyeblink with his extremely powerful twin cannons.",
		"His horribly bulky structure makes him a formidably difficult foe to overcome,",
		"so make sure you have a powerful weapon on you before confronting him.",""
	},
	//---SPIDERS---//
	//Arachnotron
	{
		"Every Arachnotron wants to be a Spider Mastermind someday. For now, they have",
		"a plasma gun that really hurts if you stay still for too long. If you want to",
		"kill these effectively, use hard heavy shots, and stay out of the plasma",
		"stream. A few rockets will do the trick.","","","",""
	},
	//Fusion Spider
	{
		"The arachnotron got a weapon upgrade. Instead of a slow-fire plasma cannon,",
		"they now have a fusion energy launcher, which releases a field of slow-moving,",
		"high-damage energy projectiles in an outward spread pattern. These walls of",
		"death crawl forward at an inexorable rate, and are extremely hard to avoid",
		"unless you have some damn good cover. Be sure to note also that the fusion",
		"spider is now slightly harder to kill than its less dangerous, but equally",
		"annoying, counterpart.",""
	},
	//---VILES---//
	//Hellion
	{
		"These nasty imp/archvile-like demons come from the deepest caverns of hell.",
		"They have no hesitation in attacking you with deadly flame bursts. They",
		"usually come in large hordes, much like Shadows, and are just as fast. So our",
		"advice is to use an effective, rapid-fire weapon in order to take them down as",
		"fast as possible.","","",""
	},
	//Archvile
	{
		"If you thought battling demons ONCE was bad, then this guy will try to make",
		"sure you face them again! And to make things worse, he's got an explosive fire",
		"attack that will hurl you into the air, doing heavy damage. Quick termination",
		"with extreme prejudice is advised.","","","",""
	},
	//Diabloist
	{
		"Some suspect the Diabloist is a lesser incarnation of Satan himself. Anything",
		"within this bastard's attack range (that is, anything within his line of",
		"sight) soon turns to ash. He has several devastating attacks, all of which",
		"involve burning, heat, flames, fire... you get the idea. When you see him, run",
		"for cover. You've got nought else to do if you don't have a weapon equally",
		"good at clearing a room as he is.","",""
	},
	//---BOSSES---//
	//Spider Mastermind
	{
		"Mechanical spider, except with half the number of legs, but still deadly. The",
		"best way to kill her is to attack from far away, and with a BFG. She does not",
		"suffer explosions like other monsters do. Rumor has it that these brainpans-",
		"on-legs used to take more of a beating than they do these days, but let's just",
		"assume that we've gotten better at it. It's better for morale.","","",""
	},
	//Spider Demolisher
	{
		"Dear God, save us all. The demons got a hold of our BFG technology, and this",
		"is the result. One of the most powerful demons we've seen in a long while,",
		"only made far worse by double the usual firepower - and that doesn't even",
		"count the destructive capabilities of the BFG they mounted on the damn thing!",
		"Rest assured, Marine, we'll make damned sure you get enough firepower to take",
		"this thing on, or else you're not going to be the only thing we lose!","",""
	},
	//Cyberdemon
	{
		"Take a regular demon, supersize him, give him a rocket launcher and other",
		"cybernetic attachments, and this guy is the result. The only way to fight this",
		"guy is with good reflexes and a super fast gun. His rockets are hard to dodge,",
		"and he doesn't feel much pain. He's also immune to explosions, except when he",
		"suffers a direct impact so rockets and pyro cannons do far less damage to him",
		"than they do to other creatures. Plasma rifles most effective.","",""
	},
	//Terminator
	{
		"Hard to differentiate between demon and machine, the terminator is probably",
		"the toughest ever enemy you will face during your missions. Its vital systems",
		"are not only protected by heavy armor, but also by powerful invisible energy",
		"fields, which allow it to absorb huge amounts of physical damage. In addition,",
		"it seems to have a nigh-infinite arsenal of destructive weaponry. With arm",
		"cannons that launch fast, explosive energy projectiles, missiles that home in",
		"on their targets, a machinegun AND a grenade launcher, you must approach this",
		"goliath with extreme caution, and perhaps a very big gun."
	},
};

script 940 ENTER
{
	int AwardGiven=CheckInventory("AwardItem"),AwardCurrent;
	while(true)
	{
		AwardCurrent=CheckInventory("AwardItem");
		if(AwardCurrent>AwardGiven)
		{
			GiveInventory("CoinItem",AwardCurrent-AwardGiven);
			AwardGiven=AwardCurrent;
		}
		delay(1);
	}
}

// Call with end=0 at start of attack, end=1 at end of attack
script 941 (int end)
{
	PrintBold(s:"TODO: Implement NightmareDemon's attack");
}

Script "FastMonsters"(void)
{
	if(GetCVar("sv_fastmonsters")||GameSkill()>=4)
		SetResultValue(1);
	else
		SetResultValue(0);
}

/* ******************************* **
** Public defines, for maps to use **
** ******************************* */

// Player 1 tid is PLAYER_TID_START, Player 2 tid is PLAYER_TID_START+1, etc.
#libdefine	PLAYER_TID_START	5000

// Radio stuff
#libdefine	RADIO_RANDOM	0
#libdefine	RADIO_PETERSEN	1
#libdefine	RADIO_PRINCE	2
#libdefine	RADIO_WILBUR	3
#libdefine	RADIO_CLOUD		4
#libdefine	RADIO_TAYLOR	5
#libdefine	RADIO_POTHEM	6
#libdefine	RADIO_CRESSWELL	7
#libdefine	RADIO_HARRELL	8
#libdefine	RADIO_GIMMER	9
#libdefine	RADIO_OSTMANN	10
#libdefine	RADIO_DRAGON	11
#libdefine	RADIO_CARNEY	12
#libdefine	RADIO_CLAUSSEN	13
#libdefine	RADIO_EMMIRATH	14
#libdefine	RADIO_KILLSAW	15
#libdefine	RADIO_METER		16

// Script numbers
#libdefine	S_BF_THRUST	254
#libdefine	S_G_THRUST	253

// Game modes
#libdefine	S_DEADLINE	901
#libdefine	S_CORE_GAME	902
#libdefine	S_MILESTONE	903
#libdefine	S_LIMIT_GAME	904
#libdefine	S_OVERMIND	905
#libdefine	S_GOAL_GAME	906

#libdefine	S_GETBONUS	980
#libdefine	S_MINUTECHECKS	981
#libdefine	S_DAMAGECHECKS	982
#libdefine 	S_DETECTENDOFLVL 983

#libdefine	S_MILE_MARKER	250
#libdefine	S_LIMIT_MARKER	249

#libdefine	S_MISSION_COMPLETE	910
#libdefine	S_M_ACTIVATE_FAIL	255
#libdefine	S_MISSION_FAIL	912
#libdefine	S_JAIL_GIVEUP	252
#libdefine	S_JAIL_LEAVE	898
#libdefine	S_JAIL_OPEN	897
#libdefine	S_BRIEF_END	251
#libdefine	S_BRIEF_MAIN	925

#libdefine	S_STR52CODEGET	927

#libdefine	S_GOAL_DESTROYED	926
#libdefine  S_CORE_WARNINGS     929

#libdefine	GOAL_RED	1
#libdefine	GOAL_ORANGE	2
#libdefine	GOAL_BLUE	3
#libdefine	GOAL_GREEN	4
#libdefine	GOAL_WHITE	5

#libdefine	WATCH_UNKN	0
#libdefine	WATCH_CORE	1
#libdefine	WATCH_BOSS	2
#libdefine	WATCH_BOSSTARGET	3
#libdefine	WATCH_LIMIT	4
#libdefine	WATCH_GOALS	5

// Many of these are not used.
#libdefine B_TIMEHALF 0
#libdefine B_TIMETHIRD 1
#libdefine B_TIMEQUARTER 2
#libdefine B_KILLS100 3
#libdefine B_KILLS200 4
#libdefine B_KILLS300 5
#libdefine B_NOMILESTONES 6
#libdefine B_NOGOALS 7
#libdefine B_CORE90 8
#libdefine B_CORE95 9
#libdefine B_CORE100 10
#libdefine B_LIMITHALF 11
#libdefine B_LIMITQUARTER 12
#libdefine B_LIMITNONE 13
#libdefine B_OVERMINDKILLER 14
#libdefine B_NOCORES 15
#libdefine B_INDIRECTKILLS1 16
#libdefine B_INDIRECTKILLS2 17
#libdefine B_INDIRECTKILLS3 18
#libdefine B_CASH1000 19
#libdefine B_CASH2000 20
#libdefine B_CASH3000 21
#libdefine B_DAMAGE100 22
#libdefine B_DAMAGE50 23
#libdefine B_NODAMAGE 24
#libdefine B_NODEATHS 25

#libdefine GAME_DEADLINE 0
#libdefine GAME_CORE 1
#libdefine GAME_MILESTONE 2
#libdefine GAME_LIMIT 3
#libdefine GAME_OVERMIND 4
#libdefine GAME_GOAL 5

// Misc
#libdefine	INT_MAX		0x7FFFFFFF

/* *************************************** **
** Public Variables that can be set by map **
** *************************************** */
int F_CallNextWave; //Cheat variable to force next wave.
int Waves,GameMode=GAME_DEADLINE,HateEpicenter,NumberOfTargets,BossMonster,BossTarget,
BossHealth=20000,EventScript,GoalScript,MileScript,CurrentMile,ExitPos,PrisonSpot,
PrisonExit,PrisonCamStart,PrisonTeleporterLineId,PrisonTeleporterThrustAngle,PrisonExitThrustAngle=-1,
TeleporterOnLight,TeleporterOffLight;
int BreakTime=-1;	// Deadline default is 6*35. Can be overridden by map.
int LimitMax=100;	// Can be overridden by map
int tics_between_monster_spawns=5;	// Can be overridden, but highly not recommended to shorten this either.
bool GameActive=TRUE;	// When this is false, the player can't lose lives
bool GameVictory,TrainingMap,TimeAttackMode;
bool GivePistol=TRUE;	// Set to false for Intermap
bool BriefSkippable=TRUE;	// If this is false, "Press <use> to skip" won't be shown
bool BriefTalking;	// When true, talking animation in briefing happens
bool BriefActive;	// Should be TRUE when players should be frozen (PROP_TOTALLY_FROZEN)
bool BriefNoGun;	// The player won't be given a gun on first spawn while this is true
str BriefBackground="TNTA0";
int BriefScript;	// Set to script number of briefing script. See STR01 for example.
int DamageTaken[32];
bool PlayersAreLate;
int LatePlayersDelay=35*20; // Time before late players are put into jail immediately.

#libdefine RADIONAME_SIZE	16
int RadioName[RADIONAME_SIZE];

int MapCoinReward[57]=
{
	0,
	0,100,200,300,400,500,600,700,800,900,
	1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,
	2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,
	3000,3100,3200,3300,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,1500,
	0,1500,0,1500,0,1500
};
int MapParTime[57]=
{
	0,
	2*60,5*60,10*60,6*60,8*60,10*60,9*60,8*60,3*60,9*60,
	9*60,10*60,8*60,10*60,11*60,19*60,10*60,15*60,15*60,10*60,
	5*60,9*60,13*60,16*60,6*60,11*60,24*60,20*60,19*60,25*60,
	13*60,22*60,14*60,19*60,30*60,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,9*60,
	0,12*60,0,11*60,0,14*60
};

// 0=level not finished
// -1=level finished, but par-time not met
// Positive number=Par time met, equals high score (in tics)
global int 1:MapScores[];
global int 2:str52code[];	// Has 5 entries, one for each digit of the code

global bool 2:str52codeinit;	// Once str52code has been set, this is set to true

global bool 51:STR50Open;
global bool 53:STR52Open;
global bool 55:STR54Open;
global bool 56:STR56Open;

// These next few shouldn't be changed - pretend they're defines :P
// (They're not set as defines so that way maps don't need to recompile if they're changed.)
int BriefX=370.0;
int BriefY=365.0;
int BriefHID=1004;
int BriefExtraHID=1003;

/* **************************************************** **
** Internal defines and variables, not referenceable or **
** should not be referenced from outside this file.     **
** **************************************************** */

#define	TEMP_TID_START	4600
#define	TEMP_TID_END	4999

#define S_ENTER		669
#define S_LIVE_WATCH	668
#define S_LATEPLAYERS 667
#define S_RESPAWN	670
#define S_DISCONNECT	923
#define	S_CALLWAVE	920
#define S_MESSAGE	921
#define S_UPDATE_MONSTER_COUNT	922
#define S_BRIEF_ANIMATE	924
#define	S_HEALTH_WATCH	911
#define	S_COUNT_WATCH	914
#define	S_LIMIT_WATCH	928
#define	S_OVERMIND_COMPLETE	918
#define	S_HUD_COINS	919

#define S_HUD		915
#define	S_TIMER		916
#define	S_SYNC		917
#define	S_VAR_CHECK	970

#define	S_DEBUG		930

// Multiplier function defines
#define M_MEDIC		1
#define M_AMMO		2
#define M_POWERUP	3
#define M_ENEMIES	4
#define M_BOSSHEALTH	5

#define	SYNC_WAVE	1
#define	SYNC_HITIME	2
#define	SYNC_LOTIME	3
#define	SYNC_PARTIME	4

#define	BriefTalkBoxX	290.0
#define	BriefTalkBoxY	360.0

#define	RadioMugHID	4
#define	RadioNameHID	5
#define	RadioTextHID	6
#define	RadioBoxHID	7

#define	BriefNameHID	1005
#define	BriefTalkBoxHID	1008
#define	BriefBGHID	1010
#define	BriefSkipHID	1002

#define	EndMessageHID	1015
#define FadeOutHID	1016

#define	CoreGraphicHID	1020
#define	CorePercentHID	1021
#define	CoreLabelHID	1022

#define	CoreHIDOffset	3
// HIDs 1023-1029 reserved

#define	HUDLevelHID	1030
#define	HUDMonstersHID	1031
#define	HUDWaveHID	1032
#define	HUDTimeHID	1033
#define	HUDParTimeHID	1034
#define	HUDParTimeLabelHID	1035
#define	HUDBodyCountHID	1036

#define	HUDRightHID	1050
#define	HUDLeftHID	1051

#define	MoneyCountHID	1100
#define	MoneyBarHID	1101

#define	CoreGraphicX	50.2
#define	CoreGraphicY	390.0
#define	CoreLabelX	50.1
#define	CoreLabelY	380.0
#define	CorePercentX	88.2
#define	CorePercentY	395.0

#define	CoreYOffset	(-30.0)

#define	WatchHudSizeX	640
#define	WatchHudSizeY	430

str WatchHudFont="BIGFONT";	// Doesn't seem to work as a define

int lastWeaponTid,MonstersTid,highestPlayerNumber,randomRadioFace;
bool isSetup;
int msgEndOfLine,msgCurTurn,TimerIsLive;
int AllVarsLocal;	// If this is false, then we're a client in a Skulltag client/server setup

int levelRunningTime,levelMinutes,levelSeconds;
str levelSecondsSpace="0";

// Value, Meaning
// 0	No par time shown
// 1	"Par Time" shown
// 2	"Best Time" shown
int parTimeMode,parTime,parTimeMinutes,parTimeSeconds;
str parTimeSecondsSpace="0";

bool jailTeleporter;
str TeleporterOnTexture="TELEPTY1",TeleporterOffTexture="TELEPTX1";
int LimitCounter;	// Number of monsters that have crossed the limit
int curWave;	// Only to be used for display purposes
bool DisableAnnounceWaveDone;	// When TRUE, finishing a wave isn't announced. Used for Overmind mode.
bool GameFinishing;	// When set to true, causes all currently running waves to shut down

#define	LEN_RADIO	16
str RadioData[LEN_RADIO][2]=
{
	{"Cpl. S. Petersen","DIALOG1"},
	{"Sgt. R. Prince","DIALOG2"},
	{"Lt. J. Wilbur",""},
	{"Col. K. Cloud",""},
	{"Pvt. D. Taylor",""},
	{"Sgt. A. Pothem",""},
	{"Cpl. J. Cresswell",""},
	{"Col. B. Harrell",""},
	{"Lt. D. Gimmer",""},
	{"Col. B. Ostmann",""},
	{"Pvt. G. Dragon",""},
	{"Sgt. B. Carney",""},
	{"Cpl. R. Claussen",""},
	{"Lt. R. Emmirath",""},
	{"Col. S. Killsaw",""},
	{"Pvt. G. Meter",""}
};

#define WAVE_ANNOUNCE_SOUNDS_LEN	20
str WaveAnnounceSounds[WAVE_ANNOUNCE_SOUNDS_LEN]=
{
	"T_WAVFNL",
	"T_WAVNR1","T_WAVNR2","T_WAVNR3","T_WAVNR4","T_WAVNR5",
	"T_WAVNR6","T_WAVNR7","T_WAVNR8","T_WAVNR9","T_WAVN10",
	"T_WAVN11","T_WAVN12","T_WAVN13","T_WAVN14","T_WAVN15",
	"T_WAVN16","T_WAVN17","T_WAVN18","T_WAVN19"
};

#define WAVE_NUM_WORDS	21
str WaveNumberWord[WAVE_NUM_WORDS]=
{
	"Final",
	"First","Second","Third","Fourth","Fifth",
	"Sixth","Seventh","Eighth","Ninth","Tenth",
	"Eleventh","Twelfth","Thirteenth","Fourteenth","Fifteenth",
	"Sixteenth","Seventeenth","Eighteenth","Nineteenth","Twentieth",
};

#define	MILE_ANNOUNCE_SOUNDS_LEN	4
str MileAnnounceSounds[MILE_ANNOUNCE_SOUNDS_LEN]=
{
	"",
	"T_MLSTN1","T_MLSTN2","T_MLSTN3"
};

#define MAXBONUSES 26
int BonusArray[MAXBONUSES][3]={
// Icon     Name                        Description                                                Award
//-------------------------------------------------------------------------------------------------------
// Time bonuses.
{"B_TIME1", "\ceTIMESTEALER",           "Completed the mission in half the par time.",             },//500},
{"B_TIME2", "\ceTIMESPLITTER",          "Completed the mission in a third of the par time.",       },//1000},
{"B_TIME3", "\ceTIMESLICER",            "Completed the mission in a quarter of the par time.",     },//1500},
// Killing bonuses.
{"B_KILL1", "\cgCARNAGE",               "Killed 100 monsters in 1 minute.",                        },//250},
{"B_KILL2", "\cgCRUSADER",              "Killed 200 monsters in 1 minute.",                        },//500},
{"B_KILL3", "\cgCATACLYSM",             "Killed 300 monsters in 1 minute.",                        },//750},
// Defense bonuses.
{"B_MILE",  "\chMILESTONE DEFENDER",    "Didn't let the demons cross one milestone.",              },//2000},
{"B_GOAL",  "\chGOAL DEFENDER",         "Didn't let the demons destroy one goal.",                 },//800},
// Core bonuses.
{"B_CORE1", "\cdCORE PROTECTOR",        "Completed the mission with the core at 90%-94%.",         },//500},
{"B_CORE2", "\cdCORE PRESERVER",        "Completed the mission with the core at 95%-99%.",         },//750},
{"B_CORE3", "\cdCORE PERFECTOR",        "Completed the mission with the core at 100%!",            },//1000},
// Limit bonuses.
{"B_LIMIT1","\cfLIMIT PROTECTOR",       "Monster limit did not exceed half.",                      },//200},
{"B_LIMIT2","\cfLIMIT PRESERVER",       "Monster limit did not exceed one third.",                 },//600},
{"B_LIMIT3","\cfLIMIT PERFECTOR",       "Didn't let a single demon pass the deadline!",            },//1000},
// Overmind bonuses.
{"B_OVER1", "\caOVERKILL",              "Killed the overmind without killing any other monsters.", },//1000},
{"B_OVER2", "\caOVERRIDE",              "Didn't let the Overmind destroy one core.",               },//1000},
// Indirect kill bonuses.
{"B_INDK1", "\ciMODERATOR",             "Killed 100 monsters indirectly.",                         },//200},
{"B_INDK2", "\ciMANIPULATOR",           "Killed 200 monsters indirectly.",                         },//600},
{"B_INDK3", "\ciMASTERMIND",            "Killed 300 monsters indirectly.",                         },//1000},
// Cash bonuses.
{"B_CASH1", "\cqMONEY MERCHANT",        "Earnt more than $1000 in one minute.",                    },//500},
{"B_CASH2", "\cqMONEY MAGNET",          "Earnt more than $2000 in one minute.",                    },//1000},
{"B_CASH3", "\cqMONEY MASTER",          "Earnt more than $3000 in one minute.",                    },//1500},
// Damage bonuses.
{"B_DAMG1", "\ctUNSTOPPABLE",           "Took less than 100 damage overall.",                      },//1000},
{"B_DAMG2", "\csINHUMAN",               "Took less than 50 damage overall.",                       },//2500},
{"B_DAMG3", "\cnGODLIKE",               "Took no damage overall.",                                 },//5000},
{"B_NODETH","\cbDOMINATOR",             "Didn't die once.",                                        },//2000},
};

int BonusAwards[MAXBONUSES]=
{500,1000,1500,250,500,750,2000,800,500,750,1000,200,600,1000,1000,1000,200,600,1000,500,1000,1500,1000,2500,5000,2000};

// Spots arrays
#define MAX_WEAPON_SPOTS	32
int WeaponSpots[MAX_WEAPON_SPOTS];
int WeaponSpotsUsed;

#define MAX_MEDIC_SPOTS		32
int MedicSpots[MAX_MEDIC_SPOTS];
int MedicSpotsUsed;

#define MAX_AMMO_SPOTS		32
int AmmoSpots[MAX_AMMO_SPOTS];
int AmmoSpotsUsed;

#define MAX_POWERUP_SPOTS	32
int PowerupSpots[MAX_POWERUP_SPOTS];
int PowerupSpotsUsed;

// Object spawn arrays

// EnemyEntries[] format is {int wave, str actor, int number}
#define MAX_ENEMY_ENTRIES	72
int EnemyEntries[MAX_ENEMY_ENTRIES][3];
int EnemyEntriesUsed;

// ZoneData[] format is {int x, int y, int xlength, int yheight, int floor, int goal, int byteangle, int zheight, int lowertid, int highertid}
#define MAX_ZONES	24
#define	ZONEDATA_WIDTH	12
int ZoneData[MAX_ZONES][ZONEDATA_WIDTH];
int ZoneDataUsed;

// WeaponItems[] format is {int wave, str actor}
#define MAX_WEAPON_ITEMS	32
int WeaponItems[MAX_WEAPON_ITEMS][2];
int WeaponItemsUsed;

// MedicItems[] format is {int wave, str actor, int number}
#define MAX_MEDIC_ITEMS		128
int MedicItems[MAX_MEDIC_ITEMS][3];
int MedicItemsUsed;

#define MAX_POWERUP_ITEMS	128
int PowerupItems[MAX_POWERUP_ITEMS][3];
int PowerupItemsUsed;

// AmmoEntries[] format is {int wave, int type, int amount}
#define MAX_AMMO_ENTRIES	256
int AmmoEntries[MAX_AMMO_ENTRIES][3];
int AmmoEntriesUsed;

// AmmoActors[] format is {int type, str actor, int amount}
int AmmoActors[11][2]=
{
	{1,10},{1,50},{2,4},{2,20},{3,1},
	{3,5},{4,20},{4,100},{5,24},{5,96},
	{6,2}
};
int AmmoActorsUsed=11;
int AmmoActorsNames[11]=
{
	"Clip","ClipBox","Shell","ShellBox","RocketAmmo",
	"RocketBox","Cell","CellPack","Gas","Fuel",
	"Mines"
};

// MapRewards[] format is {str actor, int amount}
#define MAX_MAP_REWARDS		8
int MapRewards[MAX_MAP_REWARDS][2];
int MapRewardsUsed;

// RadioMessages[] format is {int wave, int name, str message}
#define MAX_RADIO_MSGS		80
#define RADIO_MSGS_WIDTH	3
int RadioMessages[MAX_RADIO_MSGS][RADIO_MSGS_WIDTH];
int RadioMessagesUsed;

// Temp storage arrays

// WaveFinishCallback[] format is {bool isFinished}
#define MAX_NORMAL_WAVES	40
int WaveFinishCallback[MAX_NORMAL_WAVES];

#define MAX_ENEMIES_PER_WAVE	512

// EnemySpawnCache[] format is {int loc, str actor}
// ENEMY_SPAWN_CACHE_LEN is the limit of how many concurrent waves can be running at once.
#define ENEMY_SPAWN_CACHE_LEN	8
int EnemySpawnCache[ENEMY_SPAWN_CACHE_LEN][MAX_ENEMIES_PER_WAVE];
int EnemySpawnCacheUsed[ENEMY_SPAWN_CACHE_LEN];
int EnemySpawnCacheLoc;

// ItemFogCache[] format is {int spottid, int time}
#define ITEMFOG_CACHE_LEN	16
int ItemFogCache[ITEMFOG_CACHE_LEN][2];
int ItemFogCacheLoc;

// How many tics ItemFogSpawner() has to wait before being able to do fog again at a specific tid.
// Useful to prevent it being called many times at the same spot at the same time.
#define ITEMFOG_REQUIRED_TIC_DIF	6

/* ********* **
** Functions **
** ********* */

function int abs (int x)
{
	if (x < 0)
		return -x;
	return x;
}

function int min (int a, int b)
{
	if (a < b)
		return a;
	return b;
}

function int max (int a, int b)
{
	if (a > b)
		return a;
	return b;
}

function int fdistancexy (int x1, int y1, int x2, int y2)
{
	int len,ang,x=x1 - x2,y=y1 - y2;
	ang=vectorangle(x,y);
	if(((ang+0.125)%0.5) > 0.25)
		len=fixeddiv(y, sin(ang));
	else
		len=fixeddiv(x, cos(ang));
	return len;
}

// Returns fixed point value
function int floor(int fixedNumber)
{
	return fixedNumber & 0xFFFF0000;
}

// Returns fixed point value
function int fround(int fixedNumber)
{
	return floor(fixedNumber + 0.5);
}

// Function from http://zdoom.org/wiki/Getaspectratio
#define ASPECT_4_3 (4.0 / 3)
#define ASPECT_5_4 1.25
#define ASPECT_16_9 (16.0 / 9)
#define ASPECT_16_10 1.6

function int getaspectratio(void)
{
	int width=getcvar("vid_defwidth");
	int height=getcvar("vid_defheight");
	int nowidescreen=getcvar("vid_nowidescreen");
	int tft=getcvar("vid_tft");
	int aspect=getcvar("vid_aspect");
	switch(aspect)
	{
		case 1:	return ASPECT_16_9;
		case 2:	return ASPECT_16_10;
		case 3:	return ASPECT_4_3;
		case 4:	return ASPECT_5_4;
	}
	if(nowidescreen)
	{
		if(!tft)
			return ASPECT_4_3;
		if(fixedmul(height<<16, fixeddiv(5.0, 4.0))==width<<16)
			return ASPECT_5_4;
		else
			return ASPECT_4_3;
	}
	if(abs((abs(fixedmul(height<<16, fixeddiv(16.0, 9.0)))>>16) - width) < 10)
		return ASPECT_16_9;
	if(abs((abs(fixedmul(height<<16, fixeddiv(16.0, 10.0)))>>16) - width) < 60)
	{
		if((width==320 && height==200) || (width==640 && height==400))
			return ASPECT_4_3;
		return ASPECT_16_10;
	}
	if(fixedmul(height<<16, fixeddiv(5.0, 4.0))>>16==width && tft)
		return ASPECT_5_4;
	return ASPECT_4_3;
}

// Used to pad times and other fixed width numbers in output
// space(1,3) returns "00", space(12,3) returns "0", space(123,3) returns ""
str zerospaces[8]={"","0","00","000","0000","00000","000000","0000000"};
function str zerospace(int num, int spaces)
{
	int difference=spaces-numLen(num);
	if(difference>0&&difference<=7&&num>=0)
		return zerospaces[difference];
	return "";
}

// Returns number of characters num is
function int numLen(int num)
{
	int i=1;
	while(abs(num)/pow(10,i-1) >=10)
		i++;
	if(num<0) // Count the "-" sign
		i++;
	return i;
}

function int pow (int x, int n)
{
	if (n < 1)
		return 1;
	int y=x;
	while (--n)
		y *=x;
	return y;
}

// Level settings

function void AddWeaponSpot (int tid)
{
	if(WeaponSpotsUsed==MAX_WEAPON_SPOTS)
		PrintBold(s:"Error: WeaponSpots[] limit hit");
	WeaponSpots[WeaponSpotsUsed++]=tid;
}

function void AddMedicSpot (int tid)
{
	if(MedicSpotsUsed==MAX_MEDIC_SPOTS)
		PrintBold(s:"Error: MedicSpots[] limit hit");
	MedicSpots[MedicSpotsUsed++]=tid;
}

function void AddAmmoSpot (int tid)
{
	if(AmmoSpotsUsed==MAX_AMMO_SPOTS)
		PrintBold(s:"Error: AmmoSpots[] limit hit");
	AmmoSpots[AmmoSpotsUsed++]=tid;
}

function void AddPowerupSpot (int tid)
{
	if(PowerupSpotsUsed==MAX_POWERUP_SPOTS)
		PrintBold(s:"Error: PowerupSpots[] limit hit");
	PowerupSpots[PowerupSpotsUsed++]=tid;
}

function void AddZone (int bottomlefttid, int toprighttid, int patrolnode)
{
	AddZoneMile(bottomlefttid, toprighttid, patrolnode, 0);
}

function void AddZoneAlt (int bottomlefttid, int toprighttid, int patrol1, int patrol2)
{
	AddZoneBase(bottomlefttid, toprighttid, patrol1, 0, patrol2, 0, 0);
}

function void AddZoneMile (int bottomlefttid, int toprighttid, int patrolnode, int mile)
{
	AddZoneBase(bottomlefttid, toprighttid, patrolnode, mile, 0, 0, 0);
}

function void AddZoneAltMile (int bottomlefttid, int toprighttid, int patrol1, int patrol2, int mile)
{
	AddZoneBase(bottomlefttid, toprighttid, patrol1, mile, patrol2, 0, 0);
}

function void AddZoneBase (int bottomlefttid, int toprighttid, int patrol1, int mile, int patrol2, int unused1, int unused2)
{
	if(ZoneDataUsed==MAX_ZONES)
		PrintBold(s:"Error: ZoneData[] limit hit");
	// Check if this zone has already been added
	for(int i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][5]==patrol1) &&
			(ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)) &&
			(ZoneData[i][10]==mile) &&
			(ZoneData[i][11]==patrol2))
			// Zone has already been added, so do nothing.
			return;
	}
	ZoneData[ZoneDataUsed][0]=min( GetActorX(bottomlefttid), GetActorX(toprighttid) );
	ZoneData[ZoneDataUsed][1]=min( GetActorY(bottomlefttid), GetActorY(toprighttid) );
	ZoneData[ZoneDataUsed][2]=abs( GetActorX(bottomlefttid)-GetActorX(toprighttid) );
	ZoneData[ZoneDataUsed][3]=abs( GetActorY(bottomlefttid)-GetActorY(toprighttid) );
	ZoneData[ZoneDataUsed][4]=min( GetActorZ(bottomlefttid), GetActorZ(toprighttid) );
	ZoneData[ZoneDataUsed][5]=patrol1;
	ZoneData[ZoneDataUsed][6]=GetActorAngle(bottomlefttid) >> 8;
	ZoneData[ZoneDataUsed][7]=abs( GetActorZ(bottomlefttid)-GetActorZ(toprighttid) );
//	Store the tids used for the mapspots so that the zone can be referenced by functions
//	such as RemoveZone() by them.
	ZoneData[ZoneDataUsed][8]=min( bottomlefttid, toprighttid );
	ZoneData[ZoneDataUsed][9]=max( bottomlefttid, toprighttid );
	ZoneData[ZoneDataUsed][10]=mile;
	ZoneData[ZoneDataUsed][11]=patrol2;
	ZoneDataUsed++;
}

function bool RemoveWeaponSpot (int tid)
{
	int i, j,foundTids;
	for(i=0; i<WeaponSpotsUsed; i++)
	{
		if(WeaponSpots[i]==tid)
		{
			WeaponSpotsUsed--;
			foundTids++;
			for(j=i; j<WeaponSpotsUsed; j++)
			{
				WeaponSpots[j]=WeaponSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemoveMedicSpot (int tid)
{
	int i, j,foundTids;
	for(i=0; i<MedicSpotsUsed; i++)
	{
		if(MedicSpots[i]==tid)
		{
			MedicSpotsUsed--;
			foundTids++;
			for(j=i; j<MedicSpotsUsed; j++)
			{
				MedicSpots[j]=MedicSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemoveAmmoSpot (int tid)
{
	int i, j,foundTids;
	for(i=0; i<AmmoSpotsUsed; i++)
	{
		if(AmmoSpots[i]==tid)
		{
			AmmoSpotsUsed--;
			foundTids++;
			for(j=i; j<AmmoSpotsUsed; j++)
			{
				AmmoSpots[j]=AmmoSpots[j+1];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool RemovePowerupSpot (int tid)
{
	int i, j,foundTids;
	for(i=0; i<PowerupSpotsUsed; i++)
	{
		if(PowerupSpots[i]==tid)
		{
			PowerupSpotsUsed--;
			foundTids++;
			for(j=i; j<PowerupSpotsUsed; j++)
				PowerupSpots[j]=PowerupSpots[j+1];
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function void ClearItemSpawnSpots (void)
{
	WeaponSpotsUsed=0;
	MedicSpotsUsed=0;
	AmmoSpotsUsed=0;
	PowerupSpotsUsed=0;
}

function bool RemoveZone (int bottomlefttid, int toprighttid)
{
	int i, j, z,foundTids;
	for(i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)) )
		{
			ZoneDataUsed--;
			foundTids++;
			for(j=i; j<ZoneDataUsed; j++)
			{
			//	ZoneData[j]=ZoneData[j+1];
				for(z=0; z<ZONEDATA_WIDTH; z++)
					ZoneData[j][z]=ZoneData[j+1][z];
			}
			i--;
		}
	}
	if(foundTids > 0)
		return true;
	return false;
}

function bool ChangeZonePatrol (int bottomlefttid, int toprighttid, int newPatrol)
{
	int changed;
	for(int i=0; i<ZoneDataUsed; i++)
	{
		if((ZoneData[i][8]==min(bottomlefttid,toprighttid)) &&
			(ZoneData[i][9]==max(bottomlefttid,toprighttid)) )
		{
			ZoneData[i][5]=newPatrol;
			changed++;
		}
	}
	if(changed > 0)
		return true;
	return false;
}

function void ClearZones (void)
{
	ZoneDataUsed=0;
}

function void ClearSettings (void)
{
	ClearZones();
	ClearItemSpawnSpots();
}

Script S_DETECTENDOFLVL ENTER
{
	while (!GameVictory)
	{
		while (TimeAttackMode)
		{
			if ((levelRunningTime / 35) > MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)] && MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)])
			{
				acs_execute(S_MISSION_FAIL,0,1,0,0);
				//log(s:"SHIP IS GOING DOWN CAPTAIN! ",i:levelrunningtime, s:"  -  ", i:MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]);
				terminate;
			}
			delay(1);
		}
		delay(35);
	}
	if (GetLevelInfo(LEVELINFO_LEVELNUM)!=1)
		GetEndBonuses(1);
}

function void AddMapReward (str actor, int amount)
{
	if(MapRewardsUsed==MAX_MAP_REWARDS)
		PrintBold(s:"Error: MapRewards[] limit hit");
	MapRewards[MapRewardsUsed][0]=actor;
	MapRewards[MapRewardsUsed++][1]=amount;
}

//Added by Jimmy. Tweak if needed.
int bonuses[32];
int BonusQueue[MAXBONUSES];

function void GetBonus ( int bonustype )
{
	bonuses[playernumber()]++;
	log(i:bonustype,s:"    ",i:bonuses[playernumber()]);
	BonusQueue[bonuses[playernumber()]]=bonustype;
	LocalAmbientSound("Cash",128);
}

script S_GETBONUS ( int bonustype )
{
	SetHudSize(800,600,1);
	SetFont("BigFont");
	str bigmessage="";
	if(bonuses[playernumber()])
		bigmessage="Extra Bonuses Awarded!";
	HudMessage(s:bigmessage; HUDMSG_FADEOUT|HUDMSG_LOG,200,CR_WHITE,400.4,392.2,4.0+bonuses[playernumber()],1.0);
	SetFont("ConFont");
	for(int i=1; i<=bonuses[playernumber()]; i++)
	{
		HudMessage(s:BonusArray[BonusQueue[i]][1], s:" BONUS \cf($",d:BonusAwards[BonusQueue[i]],s:")";
			HUDMSG_FADEOUT|HUDMSG_LOG,200+i,CR_UNTRANSLATED,400.4,416.2+(8.0*i),4.0+bonuses[playernumber()],1.0);
		HudMessage(s:BonusArray[BonusQueue[i]][2];
			HUDMSG_FADEOUT|HUDMSG_LOG,300+i,CR_WHITE,400.4,432.2+(8.0*i)+(8.0*bonuses[playernumber()]),4.0+bonuses[playernumber()],1.0);
		GiveInventory("CoinItem",BonusAwards[BonusQueue[i]]);
	}
	bonuses[playernumber()]=0;
	SetFont("BigFont");
	for(i=0;i<=3;i++)
	{
		HudMessage(s:bigmessage; HUDMSG_FADEINOUT,199,CR_GOLD,400.4,392.2,0.0,0.5,0.5);
		delay(35);
	}
}

function void GetEndBonuses ( int correct )
{
	if (!correct) //Patch code to save me the trouble of trying to go through all themaps to fix this.
		return;
	//log(s:"Game mode - ", i:gamemode, s:"  - Activator: ", n:playernumber()+1);
	if(GameMode==GAME_MILESTONE && CurrentMile==0)
		GetBonus(B_NOMILESTONES);
	if(GameMode==GAME_GOAL && ThingCount(T_NONE, HateEpicenter)==NumberOfTargets)
		GetBonus(B_NOGOALS);
	if(GameMode==GAME_OVERMIND && ThingCount(T_NONE, HateEpicenter)==NumberOfTargets)
		GetBonus(B_NOCORES);
	if(GameMode==GAME_CORE)
	{
		if(GetActorProperty(HateEpicenter,AProp_Health)==1000)
			GetBonus(B_CORE100);
		else if(GetActorProperty(HateEpicenter,AProp_Health)>=950 && GetActorProperty(HateEpicenter,AProp_Health)<1000)
			GetBonus(B_CORE95);
		else if(GetActorProperty(HateEpicenter,AProp_Health)>=900 && GetActorProperty(HateEpicenter,AProp_Health)<950)
			GetBonus(B_CORE90);
	}
	if(GameMode==GAME_LIMIT)
	{
		if(LimitCounter==0) // Let no demons past the deadline.
			GetBonus(B_LIMITNONE);
		else if(LimitCounter<=LimitMax/4 /*&& LimitCounter>LimitMax/2*/)
			GetBonus(B_LIMITQUARTER);
		else if(LimitCounter<=LimitMax/2)
			GetBonus(B_LIMITHALF);
	}
	if(DamageTaken[PlayerNumber()]==0) // Took no damage.
		GetBonus(B_NODAMAGE);
	else if(DamageTaken[PlayerNumber()]>=50 && DamageTaken[PlayerNumber()]<100) // Took between 50 and 99 damage.
		GetBonus(B_DAMAGE100);
	else if(DamageTaken[PlayerNumber()]<50) //Took less than 50 damage.
		GetBonus(B_DAMAGE50);
	if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1) // If the map is in time attack mode.
	{
		//log(s:"Time checked");
		if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/4)
			GetBonus(B_TIMEQUARTER);
		else if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/3)
			GetBonus(B_TIMETHIRD);
		else if(levelRunningTime<=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/2)
			GetBonus(B_TIMEHALF);
	}
	ACS_ExecuteAlways(S_GETBONUS,0,0);
}

script S_DAMAGECHECKS ENTER
{
	int oldhealth=GetActorProperty(0,AProp_Health);
	delay(1);
	int newhealth=GetActorProperty(0,AProp_Health);
	if(newhealth<oldhealth)
		DamageTaken[PlayerNumber()]=DamageTaken[PlayerNumber()] + (oldhealth-newhealth);
	restart;
}

// Wave settings

function void WaveEnemy (int wave, str actor, int num)
{
	if(EnemyEntriesUsed==MAX_ENEMY_ENTRIES)
		PrintBold(s:"Error: EnemyEntries[] limit hit");
	EnemyEntries[EnemyEntriesUsed][0]=wave;
	EnemyEntries[EnemyEntriesUsed][1]=actor;
	EnemyEntries[EnemyEntriesUsed++][2]=num;
}

function void ClearWaveEnemies (void)
{
	EnemyEntriesUsed=0;
}

function void WaveMessage (int wave, int name, str message)
{
	if(RadioMessagesUsed==MAX_RADIO_MSGS)
		PrintBold(s:"Error: RadioMessages[] limit hit");
	RadioMessages[RadioMessagesUsed][0]=wave;
	RadioMessages[RadioMessagesUsed][1]=name;
	RadioMessages[RadioMessagesUsed++][2]=message;
}

// Removes all messages of a certain wave
function int RemoveWaveMessage (int wave)
{
	int i, j, z,found;
	for(i=0; i<RadioMessagesUsed; i++)
	{
		if( RadioMessages[i][0]==wave )
		{
			RadioMessagesUsed--;
			found++;
			for(j=i; j<RadioMessagesUsed; j++)
			{
			//	RadioMessages[j]=RadioMessages[j+1];
				for(z=0; z<RADIO_MSGS_WIDTH; z++)
					RadioMessages[j][z]=RadioMessages[j+1][z];
			}
			i--;
		}
	}
	return found;
}

function void ClearWaveMessages (void)
{
	RadioMessagesUsed=0;
}

//	This function is a little shortcut for maps to use. Good if we decide we want to change
//	the exact ending message later.
function void WaveMessageEnd (int wave, int name)
{
	WaveMessage(wave,name,"Incredible job, marine!");
	WaveMessage(wave,name,"You have successfully\ndefended this UAC\ninstallation!");
}

function void WaveWeapon (int wave, str actor)
{
	if(WeaponItemsUsed==MAX_WEAPON_ITEMS)
		PrintBold(s:"Error: WeaponItems[] limit hit");
	WeaponItems[WeaponItemsUsed][0]=wave;
	WeaponItems[WeaponItemsUsed++][1]=actor;
}

function void WavePowerup (int wave, str actor, int num)
{
	if(PowerupItemsUsed==MAX_POWERUP_ITEMS)
		PrintBold(s:"Error: PowerupItems[] limit hit");
	PowerupItems[PowerupItemsUsed][0]=wave;
	PowerupItems[PowerupItemsUsed][1]=actor;
	PowerupItems[PowerupItemsUsed++][2]=num;
}

function void WaveMedic (int wave, str actor, int num)
{
	if(MedicItemsUsed==MAX_MEDIC_ITEMS)
		PrintBold(s:"Error: MedicItems[] limit hit");
	MedicItems[MedicItemsUsed][0]=wave;
	MedicItems[MedicItemsUsed][1]=actor;
	MedicItems[MedicItemsUsed++][2]=num;
}

// Ammo Defines (used with WaveAmmo function)
#libdefine	BULLETS	1
#libdefine	SHELLS	2
#libdefine	ROCKETS	3
#libdefine	CELLS	4
#libdefine	GAS		5
#libdefine	MINES	6
function void WaveAmmo (int wave, int type, int amount)
{
	if(AmmoEntriesUsed==MAX_AMMO_ENTRIES)
		PrintBold(s:"Error: AmmoEntries[] limit hit");
	AmmoEntries[AmmoEntriesUsed][0]=wave;
	AmmoEntries[AmmoEntriesUsed][1]=type;
	AmmoEntries[AmmoEntriesUsed++][2]=amount;
}

function void ClearWaveItems (void)
{
	WeaponItemsUsed=0;
	PowerupItemsUsed=0;
	MedicItemsUsed=0;
	AmmoEntriesUsed=0;
}

function void ClearWaves (void)
{
	ClearWaveItems();
	ClearWaveMessages();
	ClearWaveEnemies();
}

function void ClearAll (void)
{
	ClearSettings();
	ClearWaves();
}

// Do stuff
function void CallWave (int wave)
{
	if( (wave>0) && (wave<MAX_NORMAL_WAVES))
		WaveFinishCallback[wave]=FALSE;
	ACS_ExecuteAlways(S_CALLWAVE,0,wave);
}

function void SpawnStuff (int wave)
{
	SpawnAmmo(wave);
	SpawnPowerups(wave);
	SpawnWeapons(wave);
	SpawnMedic(wave);
}

function int SpawnAmmo (int wave)
{
	int counter;
	if(!AmmoSpotsUsed)
		return counter;
	Setup();
	int curAmmoQuota,curAmmoActorIndex,spot;
	for(int i=0; i<AmmoEntriesUsed; i++)
	{
		if(AmmoEntries[i][0]==wave)
		{
			curAmmoQuota=Multiplier( M_AMMO, AmmoEntries[i][2] );
			curAmmoActorIndex=FindAmmoActor(AmmoEntries[i][1],curAmmoQuota);
			// If we don't even have enough ammo quota in the first loop to spawn even one ammo item, spawn
			// one of the smallest size anyway. The logic is that the skill multiplier might have reduced the
			// ammo quota to less than what's needed to spawn any, but the mapper still expects some ammo
			// to be given.
			if( (curAmmoActorIndex==-1) && (curAmmoQuota > 0) )
				curAmmoActorIndex=FindLeastAmmoActor(AmmoEntries[i][1]);
			while(curAmmoActorIndex !=-1)
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(AmmoActorsNames[curAmmoActorIndex], AmmoSpots[spot], tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid, 0);
				ItemFogSpawner(AmmoSpots[spot]);
				counter++;
				if (spot==AmmoSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
				curAmmoQuota -=AmmoActors[curAmmoActorIndex][1];
				curAmmoActorIndex=FindAmmoActor(AmmoEntries[i][1],curAmmoQuota);
			}
		}
	}
	return counter;
}

function int FindAmmoActor (int type, int amount)
{
	if(amount<=0)	// Quickly return -1 if we're given an impossible task
		return -1;
	int candidate=-1;
	for(int i=0; i<AmmoActorsUsed; i++)
	{
		if( (AmmoActors[i][0]==type) && (AmmoActors[i][1]<=amount) )
		{
			if( candidate==-1 )
				candidate=i;
			else if( AmmoActors[i][1]>AmmoActors[candidate][1] )
				candidate=i;
		}
	}
	return candidate;
}

function int FindLeastAmmoActor (int type)
{
	int candidate=-1;
	for(int i=0; i<AmmoActorsUsed; i++)
	{
		if( AmmoActors[i][0]==type )
		{
			if( candidate==-1 )
				candidate=i;
			else if( AmmoActors[i][1]<AmmoActors[candidate][1] )
				candidate=i;
		}
	}
	return candidate;
}

function int SpawnWeapons (int wave)
{
	int counter;
	if( ! WeaponSpotsUsed )
		return counter;
	Setup();
	bool weaponsThrusted;
	for(int i=0; i<WeaponItemsUsed; i++)
	{
		if(WeaponItems[i][0]==wave)
		{
			counter++;	// Only count unique weapons spawned, not total
			if( ! weaponsThrusted ) // Make sure we only thrust old weapons one time
			{
				// Thrust old weapon(s) out of the way
				int randomAngle=random(0,1.0),randomVelocity=random(0.75,1.0);
				SetActorVelocity(lastWeaponTid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(6.0,7.5),1,0);
				// Clear its TID so next weapons spawned can use it.
				Thing_ChangeTID(lastWeaponTid, 0);
				weaponsThrusted=TRUE;
			}
			for (int spot=0; spot<WeaponSpotsUsed; spot++)
			{
				// Spawn new weapon
				SpawnSpot(WeaponItems[i][1], WeaponSpots[spot], lastWeaponTid);
				ItemFogSpawner( WeaponSpots[spot] );
			}
		}
	}
	// This next line makes sure the weapons stay if "Weapons Stay" is set or the game is coop
	SetActorProperty(lastWeaponTid, APROP_Dropped, FALSE);
	return counter;
}

function int SpawnPowerups (int wave)
{
	int counter;
	if( ! PowerupSpotsUsed )
		return counter;
	int spot;
	for(int i=0; i<PowerupItemsUsed; i++)
	{
		if( PowerupItems[i][0]==wave )
		{
			while( ThingCountName(PowerupItems[i][1], 0) < Multiplier( M_POWERUP, PowerupItems[i][2] ) )
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(PowerupItems[i][1], PowerupSpots[spot], tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid, 0);
				ItemFogSpawner(PowerupSpots[spot]);
				counter++;
				if (spot==PowerupSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
			}
		}
	}
	return counter;
}

// This function works identical to SpawnPowerups()
function int SpawnMedic (int wave)
{
	int counter;
	if( ! MedicSpotsUsed )
		return counter;
	int spot;
	for(int i=0; i<MedicItemsUsed; i++)
	{
		if( MedicItems[i][0]==wave )
		{
			while( ThingCountName(MedicItems[i][1], 0) < Multiplier( M_MEDIC, MedicItems[i][2] ) )
			{
				int tid=UniqueTid(4600,0);
				SpawnSpot(MedicItems[i][1], MedicSpots[spot], tid);
				int randomAngle=random(0,1.0),randomVelocity=random(0.5,0.75);
				SetActorVelocity(tid,fixedmul(randomVelocity,cos(randomAngle)),fixedmul(randomVelocity,sin(randomAngle)),random(4.0,6.0),1,0);
				Thing_ChangeTid(tid, 0);
				ItemFogSpawner(MedicSpots[spot]);
				counter++;
				if (spot==MedicSpotsUsed-1)
					spot=0;
				else
					spot++; // Cycle through each spot
			}
		}
	}
	return counter;
}

// Note: ItemFogSpawner can only work on one thing at a time! Don't give it a tid of multiple things.
function void ItemFogSpawner( int spot )
{
	// Have we called ItemFogSpawner for this same spot not too long ago?
	// If so, do nothing and return out of the function.
	for(int i=0; i<ITEMFOG_CACHE_LEN; i++)
		if(ItemFogCache[i][0]==spot && (Timer() - ItemFogCache[i][1]) < ITEMFOG_REQUIRED_TIC_DIF)
			return;
	ItemFogCache[ItemFogCacheLoc][0]=spot;
	ItemFogCache[ItemFogCacheLoc++][1]=Timer();
	if(ItemFogCacheLoc==ITEMFOG_CACHE_LEN)
		ItemFogCacheLoc=0;
	Spawn("ItemFog",GetActorX(Spot)+random(-8.0,8.0),GetActorY(Spot)+random(-8.0,8.0),GetActorZ(Spot)+random(8.0,16.0), 0, 0);
	ThingSound(spot, "misc/spawn", 127); // lovely flange
}

// Internal, probably shouldn't be called by a map directly
function void GiveMapRewards (void)
{
	for(int i=0; i<=highestPlayerNumber; i++)
	{
		for(int j=0; j<MapRewardsUsed; j++)
			GiveActorInventory(PLAYER_TID_START+i,MapRewards[j][0],MapRewards[j][1]);
	}
}

function void AnnounceNewWave (int wave)
{
	if((wave>0)&&(wave<=Waves)) // Don't announce for special negative waves or post-final wave
	{
		curWave=wave;
		UpdateWaveTrackers();
		UpdateTime();
	//	if(wave>1) // Don't announce for wave 1
	//	{
			SetHudSize(512,384,1);
			SetFont("BigFont");
			if(wave==Waves)
				wave=0;	 // Index 0 points to "Final"
			if(wave<WAVE_NUM_WORDS)
				HudmessageBold(s:WaveNumberWord[wave],s:"\cc Wave!";
					HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
			else
				HudMessageBold(s:"Wave ",d:wave,s:"\cc!";
					HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
			if( wave<WAVE_ANNOUNCE_SOUNDS_LEN )
				AmbientSound(WaveAnnounceSounds[wave],127);
	//	}
	}
}

function void AnnounceWaveDone (int wave)
{
	if(DisableAnnounceWaveDone)
		return;
	if((wave>0)&&(wave<=Waves)) // Don't announce for special negative waves or post-final wave
	{
		SetHudSize(512,384,1);
		SetFont("BigFont");
		if(wave==Waves)
			wave=0;	 // Index 0 points to "Final"
		if(wave<WAVE_NUM_WORDS)
			HudmessageBold(s:WaveNumberWord[wave],s:" Wave \ccComplete!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		else
			HudmessageBold(s:"Wave ",d:wave,s:" \ccComplete!";
				HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,256.0,128.1,3.0,1.0,1.0);
		AmbientSound("T_WAVDON",127);
	}
}

function void AnnounceNewMile (int mile)
{
	SetHudSize(640,480,1);
	SetFont("BigFont");
	if(mile<WAVE_NUM_WORDS)
		HudmessageBold(s:WaveNumberWord[mile],s:" Milestone \cchas been breached!";
			HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,1.0,1.0);
	else
		HudmessageBold(s:"Milestone ",d:mile,s:" \cchas been breached!";
			HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,1.0,1.0);
	if( mile<MILE_ANNOUNCE_SOUNDS_LEN )
		AmbientSound(MileAnnounceSounds[mile],127);
}

function int RandomCoords (int zone, int axis)	// 0 is x, 1 is y, 2 is z
{
	int result;
	switch (axis)
	{
	case 0:
		result=random( ZoneData[zone][0], ZoneData[zone][0]+ZoneData[zone][2] ); // origin x, origin x + xlength
		break;
	case 1:
		result=random( ZoneData[zone][1], ZoneData[zone][1]+ZoneData[zone][3] ); // origin y, origin y + yheight
		break;
	case 2:
		result=random( ZoneData[zone][4], ZoneData[zone][4]+ZoneData[zone][7] ); // floor z, floor z + zheight
		break;
	default:
		PrintBold(s:"Error: RandomCoords() called without a valid axis");
	}
	return result;
}

function void GiveDefaults (int tid, int patrolnode, int hatetarget)
{
	Thing_SetGoal( tid, patrolnode, 0, 1 );
	if(hatetarget)
		Thing_Hate( tid, hatetarget, 3);
}

function void UpdateJailTrackers (void)
{
	int inJail,i, curTrackers;
	// Count how many players are in jail
	for(i=0; i<=highestPlayerNumber; i++)
		inJail +=CheckActorInventory(PLAYER_TID_START+i,"JailTracker");
	for(i=0; i<=highestPlayerNumber; i++)
	{
		curTrackers=CheckActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers");
		if(curTrackers<inJail)
			GiveActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers",inJail-curTrackers);
		else if(curTrackers>inJail)
			TakeActorInventory(PLAYER_TID_START+i,"JailTrackerAllPlayers",curTrackers-inJail);
	}
}

function bool mapRangeFinished (int first, int last)
{
	for(int i=first; i<=last; i++)
	{
		if(MapScores[i]==0) // Map isn't finished
			return false;
	}
	return true;
}

function void Setup (void)
{
	if(!isSetup)
	{
		isSetup=TRUE;
		lastWeaponTid=UniqueTid(4600,0);
		MonstersTid=UniqueTid(4700,0);
		randomRadioFace=random(0,LEN_RADIO-1);
		if(PrisonCamStart)
		{
			SetCameraToTexture(PrisonCamStart, "CT_1", 90 );
			SetCameraToTexture(PrisonCamStart+1, "CT_2", 90 );
			SetCameraToTexture(PrisonCamStart+2, "CT_3", 90 );
			SetCameraToTexture(PrisonCamStart+3, "CT_4", 90 );
			SetCameraToTexture(PrisonCamStart+4, "CT_5", 90 );
			SetCameraToTexture(PrisonCamStart+5, "CT_6", 90 );
		}
		if(PrisonTeleporterLineId)
		{
			SetLineSpecial(PrisonTeleporterLineId, ACS_ExecuteAlways, S_JAIL_LEAVE, 0, PrisonTeleporterThrustAngle );
			SetJailTeleporter( FALSE );
		}
		AddMapReward("CoinItem", MapCoinReward[GetLevelInfo(LEVELINFO_LEVELNUM)]);
		if ( MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1 )
			setParTime(MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)], 0);
		else if ( MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)] > 0 )
			setParTime(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35, 1);
	}
}

// This function applies the multiplier for the given type to amount, and returns the result.
// It handles fixed point conversion and making sure the result is rounded nicely.
// Also, if given a negative amount, it will return it positive and unmultiplied
function int Multiplier (int type, int amount)
{
	if(amount < 0)
		return 0 - amount;
	int result=amount * RawMultiplier(type);
	if( (result>0.0) && (result<1.0) )	// Make sure our answer is at least one
		result=1;
	else
		result=result / 1.0;		// Make result an integer
	return result;
}

int SkillScaler[5]={ 0.6, 0.75, 1.0, 1.5, 2.0 };

// This function returns the multiplier as a fixed point value.
// If the multiplier needs to be tweaked, this is the function to do it in.
function int RawMultiplier (int type)
{
	int result=1.0;
	switch(type)
	{
	case M_POWERUP:
		result=1.0*PlayerCount();
		break;
	case M_MEDIC:
	case M_AMMO:
		result=0.3 + 0.71*PlayerCount();	// Slightly above 1.0 for one player to account for rounding errors
		break;
	case M_ENEMIES:
		result=FixedMul(0.5 + 0.51*PlayerCount(), SkillScaler[GameSkill()]);
		break;
	case M_BOSSHEALTH:
		// 1 player=1x
		// 8 players=3x
		// result=2/7 * playercount + 5/7
		// result=(2*playercount + 5) / 7
		result=( 2.0*PlayerCount() + 5.0 ) / 7; // Dividing fixed by int yields a fixed
		break;
	default:
		PrintBold(s:"Error: Function Multiplier() called without a valid type argument");
	}
	return result;
}

function void ScreenFadeOut (int inTime) // time is a float value in seconds
{
	SetFont("BLACK");
	SetHudSize(4,4,1);
	HudMessageBold (s:"a"; HUDMSG_FADEINOUT, FadeOutHID, CR_UNTRANSLATED,2.0, 2.0,1000.0, inTime, 1.0);
	SetHudSize(0,0,0);
}

/* ******* **
** Scripts **
** ******* */

script S_MISSION_COMPLETE (void)
{
	Setup();
	if(GameActive)
	{
		bool newRecord,MapCompleted;
		SetPlayerProperty(1, 2, PROP_INVULNERABILITY);
		// Set the player invulverable so he can't die after winning the game
		SetActorProperty(HateEpicenter, APROP_Invulnerable, true);
		  // Core is made invulnerable so it can't be destroyed after winning.
		// Jimmy: I really butchered this script. Sorry about that. :S
		if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==0)
		{
			MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]=-1;
			MapCompleted=true;
		}
		else if(levelRunningTime<MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]*35)
			newRecord=true;
		GameActive=FALSE;
		StopTimer();
		SetMusic("");
		AmbientSound("TB_VICT", 127);
		GameVictory=TRUE;
		TimeAttackMode=FALSE;
		SetHudSize (640, 480, 1);
		SetFont("HUDMC");
		HudMessageBold (s:"a"; HUDMSG_FADEINOUT, EndMessageHID, CR_UNTRANSLATED,320.0, 240.0,4.0, 0.5, 0.5);
		delay(3*35);
		ScreenFadeOut(3.0);
		delay(5*35);
		if (!MapCompleted) // If the player has been playing in time attack mode.
		{
			SetPlayerProperty(1, true, PROP_TOTALLYFROZEN);
			SetHudSize (480, 360, 1);
			SetFont("BigFont");
			int lseconds=(levelRunningTime/35)%60;
			int lminutes=(levelRunningTime/35)/60;
			HudMessageBold(s:"Time Taken: \cg",s:zerospace(lminutes,2),d:lminutes,s:":",s:zerospace(lseconds,2),d:lseconds;
				HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_WHITE, 240.0, 120.1, 7.0, 1.5, 1.0);
			//delay(35/2);
			int mseconds=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]%60;
			int mminutes=MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]/60;
			HudMessageBold(s:"Par Time: \cg",s:zerospace(mminutes,2),d:mminutes,s:":",s:zerospace(mseconds,2),d:mseconds;
				HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_WHITE, 240.0, 160.1, 7.0, 1.5, 1.0);
			if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)] !=0)
			{
				int bseconds=(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35)%60;
				int bminutes=(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]/35)/60;
				HudMessageBold(s:"Best Time: \cg",s:zerospace(bminutes,2),d:bminutes,s:":",s:zerospace(bseconds,2),d:bseconds;
					HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_WHITE, 240.0, 200.1, 7.0, 1.5, 1.0);
			}
			if(newRecord)
			{
				MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]=levelRunningTime;
				//Log(s:"Extra Credit: ", d:(MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]-(levelRunningTime/35))*10);
				GiveInventory("CoinItem", (MapParTime[GetLevelInfo(LEVELINFO_LEVELNUM)]-(levelRunningTime/35))*10);
				HudMessageBold(s:"A new record!";
					HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_GREEN, 240.0, 240.1, 6.0, 2.5, 1.0);
			}
			else
				HudMessageBold(s:"Record not beaten";
					HUDMSG_FADEINOUT|HUDMSG_LOG, 0, CR_ORANGE, 240.0, 240.1, 6.0, 2.5, 1.0);
			delay(10*35);
			SetPlayerProperty(1, false, PROP_TOTALLYFROZEN);
		}
		SetPlayerProperty(1, false, PROP_INVULNERABILITY);
		GiveMapRewards();
		if(GetLevelInfo(LEVELINFO_LEVELNUM)==35)
			Exit_Secret(ExitPos);
		else
			Exit_Normal(ExitPos);
	}
}

// Placed on lines so living, enemy monsters can cause the mission to fail
script S_M_ACTIVATE_FAIL (void)
{
	// Don't continue if the activator is a dead monster or friendly
	if(GameActive &&
		( (ClassifyActor(0) & ( ACTOR_MONSTER | ACTOR_DEAD )) !=( ACTOR_MONSTER | ACTOR_DEAD ) ) &&
		( !GetActorProperty(0, APROP_Friendly) ) )
		ACS_Execute(S_MISSION_FAIL, 0, 0);
}

script S_MISSION_FAIL (void)
{
	if(!GameActive)
		Terminate;
	GameActive=FALSE;
	TimeAttackMode=FALSE;
	StopTimer();
	SetMusic("");
	AmbientSound("TB_LOST", 127);
	SetHudSize (640, 480, 1);
	if (MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]==-1)
	{
		SetFont("HUDTH");
		HudMessageBold (s:"a"; HUDMSG_FADEINOUT, EndMessageHID, CR_UNTRANSLATED,320.0, 240.0,5.0, 0.5, 0.5);
	}
	else
	{
		SetFont("HUDGO");
		HudMessageBold (s:"a"; HUDMSG_FADEINOUT, EndMessageHID, CR_UNTRANSLATED,320.0, 240.0,5.0, 0.5, 0.5);
	}
	ScreenFadeOut( 5.0 );
	delay(35 * 3);
	AmbientSound("T_FAIL", 127); // "You have failed to defend your Stronghold"
	delay(35 * 4);
	Exit_Secret(ExitPos);
}

script S_DEADLINE (void)
{
	if(BreakTime==-1)	// Default setting
		BreakTime=3*35;
	StartTimer();
	int ThisWave;
	for(ThisWave=1; ThisWave<=Waves; ThisWave++)
	{
		if(!F_CallNextWave)
			CallWave(ThisWave);
		while(! WaveFinishCallback[ThisWave] && !F_CallNextWave)
			delay(1);
		if(ThisWave==Waves)
		{
			StopTimer();		// Stop timer soon as last wave is over
		    BreakTime=3*35; // Added by Jimmy.
			// It allows players to read the last wavemessages on maps with high BreakTime (such as most limit maps).
		}
		if (F_CallNextWave)
		{
			//WaveFinishCallback[ThisWave]=TRUE;
			delay(BreakTime);
			if (F_CallNextWave > 1 && (F_CallNextWave - 1) + ThisWave < Waves)
				ThisWave +=(F_CallNextWave - 1);
			Else If (F_CallNextWave > 1 && (F_CallNextWave - 1) + ThisWave >=Waves)
			{
				acs_execute(S_MISSION_COMPLETE,0,0,0,0);
				terminate;
			}
			if (F_CallNextWave < 0 && (F_CallNextWave) + ThisWave >=1)
				ThisWave +=(F_CallNextWave);
			Else If (F_CallNextWave < 0 && (F_CallNextWave) + ThisWave <=0)
				ThisWave=0;
			F_CallNextWave=0;
		}
		else
		Delay(5*35);
	}
	StopTimer();
	// Call the last wave, to spawn maybe extra items, do a special map action, or a message, but don't wait on it.
	CallWave(ThisWave);
	Delay(3*35);	// Wait a moment before ending the script, so the ending screen or whatever the map does next
			// isn't too immediate.
}

script S_CORE_GAME (void)
{
	GameMode=GAME_CORE;
	HealthWatch(HateEpicenter,GetActorProperty(HateEpicenter, APROP_SpawnHealth),S_MISSION_FAIL,WATCH_CORE);
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

#define	MAX_WATCH_SLOTS	3
int WatchSlot[MAX_WATCH_SLOTS];

function int reserveOpenWatchSlot (void)
{
	for(int i=0; i<MAX_WATCH_SLOTS; i++)
	{
		if(!WatchSlot[i])
		{
			WatchSlot[i]=TRUE;
			return i;
		}
	}
	PrintBold(s:"Error: Out of Watch Slots");
	return 0;
}

function void ClearWatchHUD (int offset)
{
	HudMessageBold(s:""; HUDMSG_PLAIN, CoreLabelHID+CoreHIDOffset*offset,	CR_UNTRANSLATED, 0.0, 0.0, 0.1);
	HudMessageBold(s:""; HUDMSG_PLAIN, CoreGraphicHID+CoreHIDOffset*offset,	CR_UNTRANSLATED, 0.0, 0.0, 0.1);
	HudMessageBold(s:""; HUDMSG_PLAIN, CorePercentHID+CoreHIDOffset*offset,	CR_UNTRANSLATED, 0.0, 0.0, 0.1);
	WatchSlot[offset]=FALSE;
}

function void WatchTitle(int type, int offset)
{
	str name="Unknown",graphic="HUDGFXC";
	// Names
	switch(type)
	{
	case WATCH_CORE:
		name="Core";
		break;
	case WATCH_BOSS:
		name="Boss";
		graphic="HUDBOSS";
		break;
	case WATCH_BOSSTARGET:
		name="Targets";
		graphic="HUDGFXC2";
		break;
	case WATCH_LIMIT:
		name="Limit";
		graphic="HUDDEMON";
		break;
	case WATCH_GOALS:
		name="Goals";
		graphic="HUDTRGT";
		break;
	}
	SetHudSize(640, 430, 0);
	SetFont("SMALLFONT");
	HudMessageBold(s:name; HUDMSG_PLAIN, CoreLabelHID+CoreHIDOffset*offset, CR_GRAY,
	CoreLabelX, CoreLabelY+CoreYOffset*offset, 0.0);
	SetFont(graphic);
	HudMessageBold(s:"a"; HUDMSG_PLAIN, CoreGraphicHID+CoreHIDOffset*offset, CR_UNTRANSLATED,
	CoreGraphicX, CoreGraphicY+CoreYOffset*offset, 0.0);
	SetHudSize(0, 0, 0);	// Reset this so the calling script is back to the defaults
}

function void WatchAnnounceChange(int type, int value, int maxnum)
{
	// Jump out now if we know we're doing nothing.
	if(type==WATCH_CORE||type==WATCH_BOSS||type==WATCH_GOALS)
		return;
	SetFont("SMALLFONT");
	switch(type)
	{
	case WATCH_BOSSTARGET:
		if(value==maxnum)	// Don't announce when we have all cores still left
			break;
		AmbientSound("amb16",127);
		if(value==0)
			PrintBold(s:"\cgAll \cccores have been destroyed!");
		else
			PrintBold(s:"\cg",d:value,s:" / ",d:maxnum,s:" \cccores remaining!");
		break;
	case WATCH_LIMIT:
		if(value > 0)
			PrintBold(s:"\cg",d:value,s:" / ",d:maxnum,s:"\cc have made it through!");
		break;
	}
//	SetHudSize(WatchHudSizeX, WatchHudSizeY, 0);
	SetFont(WatchHudFont);
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void HealthWatch(int tid, int maxhealth, int deadscript, int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type, offset);
	ACS_Execute( S_HEALTH_WATCH, 0, tid, maxhealth, deadscript | (offset<<12) | (type<<16) );
}

script S_HEALTH_WATCH (int tid, int maxhealth, int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,color,curpercent;
	SetHudSize(WatchHudSizeX, WatchHudSizeY, 0);
	SetFont(WatchHudFont);
	while(true)
	{
		curpercent=GetPercent( GetActorProperty(tid, APROP_Health), maxhealth );
		if(GameMode==GAME_CORE)
			color=GetPercentColorCore( curpercent );
		else
			color=GetPercentColor( curpercent );
		HudMessageBold(d:curpercent,s:"%";
			HUDMSG_PLAIN, CorePercentHID+CoreHIDOffset*offset, color, CorePercentX, CorePercentY+CoreYOffset*offset, 0.0);
		WatchAnnounceChange(type,curpercent,100);
		if(GetActorProperty(tid, APROP_HEALTH) <=0)
			break;
		delay(15);
		// We don't need to update the screen until the health changes enough to change the
		// actual percent display value
		while( GetPercent( GetActorProperty(tid, APROP_HEALTH), maxhealth )==curpercent )
			delay(5);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript, 0, 0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void CountWatch(int tid, int maxnum, int deadscript, int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type, offset);
	ACS_Execute( S_COUNT_WATCH, 0, tid, maxnum, deadscript | (offset<<12) | (type<<16) );
}

script S_COUNT_WATCH (int tid, int maxnum, int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,
	color,curcount;
	SetHudSize(WatchHudSizeX, WatchHudSizeY, 0);
	SetFont(WatchHudFont);
	while(true)
	{
		curcount=ThingCount( T_NONE, tid );
		color=GetPercentColor( GetPercent( curcount, maxnum ) );
		HudMessageBold(d:curcount,s:"/",d:maxnum;
			HUDMSG_PLAIN, CorePercentHID+CoreHIDOffset*offset, color, CorePercentX-15.2, CorePercentY+CoreYOffset*offset, 0.0);
		WatchAnnounceChange(type,curcount,maxnum);
		if(curcount <=0)
			break;
		delay(5);
		// We don't need to update the screen until the count changes
		while( ThingCount( T_NONE, tid )==curcount )
			delay(5);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript, 0, 0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

// Scripts can't have strings passed to them, so handle the string in a wrapper function
function void LimitWatch(int maxnum, int deadscript, int type)
{
	int offset=reserveOpenWatchSlot();
	WatchTitle(type, offset);
	ACS_Execute( S_LIMIT_WATCH, 0, maxnum, deadscript | (offset<<12) | (type<<16) );
}

script S_LIMIT_WATCH (int maxnum, int data)
{
	int deadscript=(data&0x00000FFF),offset=(data&0x0000F000)>>12,type=(data&0x000F0000)>>16,
	color,curcount;

	SetHudSize(WatchHudSizeX, WatchHudSizeY, 0);
	SetFont(WatchHudFont);
	while(true)
	{
		curcount=LimitCounter;
		// We want the color to match the percent of limits not reached yet
		color=GetPercentColor( GetPercent( maxnum-curcount, maxnum ) );
		HudMessageBold(d:curcount,s:"/",d:maxnum;
			HUDMSG_PLAIN, CorePercentHID+CoreHIDOffset*offset, color, CorePercentX-38.1, CorePercentY+CoreYOffset*offset, 0.0);
		WatchAnnounceChange(type,curcount,maxnum);
		if(curcount >=maxnum)
			break;
		// We don't need to update the screen until the count changes
		while(LimitCounter==curcount)
			delay(1);
	}
	delay(45);
	if(deadscript)
		ACS_Execute(deadscript, 0, 0);
	delay(5*35 + 10); // A bit over 5 seconds
	ClearWatchHUD(offset);
}

script S_MILESTONE (void)
{
	GameMode=GAME_MILESTONE;
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_LIMIT_GAME (void)
{
	GameMode=GAME_LIMIT;
	if(BreakTime==-1)	// Default setting
		BreakTime=12*35;
	LimitCounter=0;
	LimitWatch(LimitMax,S_MISSION_FAIL,WATCH_LIMIT);
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_OVERMIND (void)
{
	// Set up boss monster
	GameMode=GAME_OVERMIND;
	int OriginalHealth=Multiplier( M_BOSSHEALTH, BossHealth );
	SetActorProperty(BossMonster, APROP_Health, OriginalHealth);
	Thing_Hate(BossMonster, BossTarget, 2);
	Thing_Activate(BossMonster);
	NumberOfTargets=ThingCount( T_NONE, BossTarget );
	HealthWatch(BossMonster,OriginalHealth,S_OVERMIND_COMPLETE,WATCH_BOSS);
	CountWatch(BossTarget,ThingCount( T_NONE, BossTarget ),S_MISSION_FAIL,WATCH_BOSSTARGET);
	DisableAnnounceWaveDone=TRUE;
	StartTimer();
	for(int i=1; i<=Waves; i++)
	{
		CallWave(i);
		Delay(4*35);
		while( GetActorProperty(BossMonster, APROP_Health) > OriginalHealth * (Waves-i) / Waves )
			delay(5);
	}
	Suspend;
	// Gameplay control continues in S_OVERMIND_COMPLETE.
	// This script left suspended so that it can be terminated later, and level control continues.
}

script S_OVERMIND_COMPLETE (void)
{
	if(MonstersTid)
		Thing_Damage(MonstersTid, INT_MAX);
	GameFinishing=TRUE;	// Stop all running waves
	ACS_Suspend( S_OVERMIND, 0 );	// Pause Overmind script so it doesn't continue launching waves
	StopTimer();
	// Call the last wave, to spawn maybe extra items, do a special map action, or a message, but don't wait on it.
	CallWave(Waves+1);
	Delay(3*35);	// Wait a moment before ending the script, so the ending screen or whatever the map does next
			// isn't too immediate.
	ACS_Terminate( S_OVERMIND, 0 );
}

script S_MILE_MARKER (int mile)
{
	if(mile==0)
		// There's no reason to call this script with mile==0, so this was most likely
		// a mapping error.
		PrintBold(s:"Error: S_MILE_MARKER script #250 called with argument 0");
	// Don't continue if the activator is a dead monster or friendly
	if((mile>CurrentMile) &&
		( (ClassifyActor(0) & ( ACTOR_MONSTER | ACTOR_DEAD )) !=( ACTOR_MONSTER | ACTOR_DEAD ) ) &&
		( !GetActorProperty(0, APROP_Friendly) ) )
	{
		AnnounceNewMile(mile);
		if(MileScript)
		{
			// A milestone might've possibly been skipped. Bad level design? Maybe.
			// But let's execute the MileScript for each time
			for(int i=CurrentMile+1; i<=mile; i++)
			{
				// Delay between calling scripts so that they're called in the right order.
				// No need to delay on the first iteration.
				if(i !=CurrentMile+1)
					delay(1);
				ACS_ExecuteAlways(MileScript, 0, i);
			}
		}
		CurrentMile=mile;
	}
}

script S_LIMIT_MARKER (void)
{
	// Don't continue if the activator is a dead monster or friendly
	if(GameActive &&
		( (ClassifyActor(0) & ACTOR_MONSTER)==ACTOR_MONSTER ) &&
		( (ClassifyActor(0) & ( ACTOR_MONSTER | ACTOR_DEAD )) !=( ACTOR_MONSTER | ACTOR_DEAD ) ) &&
		( !GetActorProperty(0, APROP_Friendly) ) )
	{
		Spawn("TeleportFog",GetActorX(0)+random(-8.0,8.0),GetActorY(0)+random(-8.0,8.0),GetActorZ(0)+random(8.0,16.0) );
		Thing_Remove(0);
		LimitCounter++;
	}
}

script S_GOAL_GAME (void)
{
	GameMode=GAME_GOAL;
	CountWatch(HateEpicenter,ThingCount( T_NONE, HateEpicenter ),S_MISSION_FAIL,WATCH_GOALS);
	NumberOfTargets=ThingCount( T_NONE, HateEpicenter );
	ACS_ExecuteWait(S_DEADLINE,0,0);
}

script S_GOAL_DESTROYED (int color)
{
	switch(color)
	{
	case GOAL_RED:
		printbold(s:"\cARed \cGGoal has been destroyed!");
		break;
	case GOAL_ORANGE:
		printbold(s:"\cIOrange \cGGoal has been destroyed!");
		break;
	case GOAL_BLUE:
		printbold(s:"\cHBlue \cGGoal has been destroyed!");
		break;
	case GOAL_GREEN:
		printbold(s:"\cDGreen \cGGoal has been destroyed!");
		break;
	case GOAL_WHITE:
		printbold(s:"\cJWhite \cGGoal has been destroyed!");
		break;
	default:
		printbold(s:"Error: Invalid goal color");
		Terminate;
	}
	if(GoalScript)
		ACS_ExecuteAlways(GoalScript, 0, ThingCount(T_NONE, HateEpicenter) );
}

script S_CORE_WARNINGS (int healthleft)
{
	SetHudSize(640,480,1);
	SetFont("BigFont");
	switch(healthleft)
	{
	case 1:
		HudmessageBold(s:"Core \ccis under attack!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_GREEN,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRATTK", 128);
		break;
	case 2:
		HudmessageBold(s:"Core \ccis sustaining damage!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_YELLOW,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRHEVY", 128);
		break;
	case 3:
		HudmessageBold(s:"Core \ccis reaching critical mass!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_RED,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRUNST", 128);
		break;
	case 4:
		HudmessageBold(s:"Core \cchas been destroyed!";
		HUDMSG_FADEINOUT|HUDMSG_LOG,0,CR_BLACK,320.0,130.1,3.0,0.0,1.0);
		AmbientSound("T_CRDEST", 128);
	}
	delay(35*4);
}

function int GetPercent (int value, int maxval)
{
	int candidate=(value*100)/maxval;
	// Check if we rounded down to zero; return at least 1 if we did
	if( (candidate==0) && (value>0) )
		return 1;
	// Don't give a negative percent
	return max( candidate, 0 );
}

function int GetPercentColor (int percent)
{
	if (percent > 75)
		return CR_GREEN;
	else if (percent <=75 && percent > 50)
		return CR_YELLOW;
	else if (percent <=50 && percent > 25)
		return CR_ORANGE;
	return CR_RED;
}

function int GetPercentColorCore (int percent)
{
	if (percent > 66)
		return CR_GREEN;
	else if (percent <=66 && percent > 33)
		return CR_YELLOW;
	return CR_RED;
}

// Don't call this script directly, use CallWave() function
// This is so that the WaveFinishCallback can be set to false synchronously, so that way it can be
// waited on.
script S_CALLWAVE (int wave)
{
	Setup();
	if(EventScript)
		ACS_ExecuteAlways(EventScript,0,wave);
	Delay(3);	// Not only a slight pause, but lets the EventScript make changes first.
			// Called even when there isn't an EventScript just for consistency.
	SpawnStuff(wave);
	// Give player time to grab items before wave messages and enemies spawn.
	Delay( BreakTime );
	AnnounceNewWave(wave);
	ACS_ExecuteAlways(S_MESSAGE,0,wave);
	Delay( 5*35 );
	// Monster spawning
	if( ZoneDataUsed )
	{
		int cacheUsed,cacheId=EnemySpawnCacheLoc++;
		if(EnemySpawnCacheLoc==ENEMY_SPAWN_CACHE_LEN)
			EnemySpawnCacheLoc=0;
		// Load all monsters to spawn this wave into EnemySpawnCache[cacheId]
		for(int i=0; i<EnemyEntriesUsed; i++)
		{
			if(EnemyEntries[i][0]==wave)
				// Every monster instance is given its own slot inside the EnemySpawnCache
				for(int j=0; j<Multiplier( M_ENEMIES, EnemyEntries[i][2] ); j++)
					EnemySpawnCache[cacheId][cacheUsed++]=EnemyEntries[i][1];
		}
		if(cacheUsed>MAX_ENEMIES_PER_WAVE)
		{
			PrintBold(s:"Error: Wave ",d:wave,s:" exceeds MAX_ENEMIES_PER_WAVE");
			cacheUsed=MAX_ENEMIES_PER_WAVE;
		}
		int cacheUsedCounter=cacheUsed,curEnemyId,curEnemyName,spawned,zone=PickZone(CurrentMile);
		// While we still have monsters left to spawn, spawn them
		while(cacheUsedCounter > 0)
		{
			spawned=FALSE;
			curEnemyId=random(0,cacheUsedCounter-1);
			for(int k=0; k <=curEnemyId; k++)
			{
				// Every time we hit a null entry, skip over it and pretend we didn't
				// see it.
				//	Q: Why not just pick the entry first, check if it's null,
				//	and then just go forward to the next non-null one?
				//	A: If we did that, then a monster entry proceeding a series of
				//	nulls would have a higher chance of being picked than others.
				if(EnemySpawnCache[cacheId][k]=="NULL")
					curEnemyId++;
			}
		// We want to repeatedly try to spawn the monster until it has spawned.
		// Note that while attempting to spawn the monster, no monsters spawn
		// at other zones. Not sure if this is worth fixing or to be considered
		// a gameplay "feature".
		//	Possible solutions:
		//	* If monster doesn't spawn, try to spawn at next zone.
		//		- One zone can have (possibly significantly) more monsters spawned.
		//	* Split up EnemySpawnCache between zones, and give each zone its own
		//	thread/script to control its spawning.
		//		- A zone can take longer to spawn its monsters than other zones.
			while(!spawned)
			{
				if(!GameActive||GameFinishing||F_CallNextWave)
					Terminate;
				int tid=UniqueTid(4600,0);
				spawned=Spawn(EnemySpawnCache[cacheId][curEnemyId],
					RandomCoords(zone,0), RandomCoords(zone,1),
					RandomCoords(zone,2), tid, ZoneData[zone][6]);
				if(spawned)
				{
					SpawnSpot("TeleportFog", tid);
					// If the zone has no second patrol, or random==TRUE, pick first patrol
					if((!ZoneData[zone][11]) || (random(0,1)))
						GiveDefaults(tid, ZoneData[zone][5], HateEpicenter);
					else
						GiveDefaults(tid, ZoneData[zone][11], HateEpicenter);
					Thing_ChangeTID(tid, MonstersTid);
				}
				delay( tics_between_monster_spawns );
			}
			// Remove the enemy just spawned from the cache
			EnemySpawnCache[cacheId][curEnemyId]="NULL";
			cacheUsedCounter--;
			zone=GetNextZone(zone, CurrentMile); // Cycle through each zone
		}
	Thing_ChangeTID(tid,0);
	}
	// Wait until all monsters are dead or if the next level cheat is called
	while(GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)-GetLevelInfo(LEVELINFO_KILLED_MONSTERS) > 0)
		delay(1);
	AnnounceWaveDone(wave);
	WaveFinished(wave);
}

function void WaveFinished(int wave)
{
	if( (wave>0) && (wave<MAX_NORMAL_WAVES))
		WaveFinishCallback[wave]=TRUE;
}

// Pick the first zone that is for the current mile
function int PickZone (int mile)
{
	int candidate=-1;
	for(int i=0; i<ZoneDataUsed; i++)
	{
		if(ZoneData[i][10]==mile)
		{
			candidate=i;
			break;
		}
	}
	if(candidate==-1)
	{
		PrintBold(s:"Error: No zones for mile ",d:mile);
		return 0;
	}
	return candidate;
}

function int GetNextZone (int curZone, int mile)
{
	int candidate=-1;
	for(int i=curZone+1; i<ZoneDataUsed; i++)
	{
		if(ZoneData[i][10]==mile)
		{
			candidate=i;
			break;
		}
	}
	if(candidate==-1)
		// We reached the end without finding a zone, so pick one from the beginning
		return PickZone(mile);
	return candidate;
}

// Always use ACS_ExecuteAlways to call this script, and it will queue up messages if needed
script S_MESSAGE (int wave)
{
	Setup();
	int ticketNumber=msgEndOfLine++;
	while(ticketNumber !=msgCurTurn)
		delay(1);
	int curFace;
	for(int i=0; i<RadioMessagesUsed; i++)
	{
		if(RadioMessages[i][0]==wave)
		{
			if(RadioName[ RadioMessages[i][1] ]==RADIO_RANDOM)
				curFace=randomRadioFace;
			else
				curFace=RadioName[i] - 1;

			// Show Mug shot of speaker
			// SetFont(RadioData[curFace][1]);
			// HudmessageBold(s:"A"; HUDMSG_PLAIN, RadioMugHID, -1, 32.1, 100.0, 4.5);
			SetHudSize(800,600,1);
			// Show his name
			SetFont("ConFont");
			HudmessageBold(s:RadioData[curFace][0]; HUDMSG_PLAIN, RadioNameHID, CR_WHITE, 44.1, 80.1, 4.5);
			// Show message text
			HudmessageBold(s:RadioMessages[i][2]; HUDMSG_TYPEON|HUDMSG_LOG, RadioTextHID, CR_GOLD, 44.1, 110.1, 99.0, 0.03, 0.5);
			// Show the dialog box
			SetFont("DIALOGBX");
			HudmessageBold(s:"A"; HUDMSG_FADEINOUT, RadioBoxHID, CR_WHITE, 32.1, 134.0, 4.35, 0.15, 0.0);
			AmbientSound("misc/chat", 64);
			delay((4.5*35)/1.0);
		}
	}
	HudmessageBold(s:""; HUDMSG_PLAIN, RadioTextHID, CR_UNTRANSLATED, 0.0, 0.0, 0.1);
	delay((0.7*35)/1.0); // Wait about half a second before letting any queued messages go to avoid a quick flicker
	msgCurTurn++;	// Let next message in line go
}

script S_ENTER ENTER
{
	if(!CheckInventory("StartingToken"))	//Gives 3 lives and 300 coins to any playerclass
	{
		GiveInventory("LifeItem",3);
		GiveInventory("CoinItem",300);
		GiveInventory("StartingToken",1);
	}
	Thing_ChangeTID(0, PLAYER_TID_START + PlayerNumber());
	highestPlayerNumber=max( PlayerNumber(), highestPlayerNumber );
	// Weapons
	TakeInventory("StrongholdChainsaw", INT_MAX);
	TakeInventory("AutoShotgun", INT_MAX);
	TakeInventory("StrongholdSuperShotgun", INT_MAX);
	TakeInventory("SuperShotgun", INT_MAX);
	TakeInventory("StrongholdShotgun", INT_MAX);
	TakeInventory("Shotgun", INT_MAX);
	TakeInventory("StrongholdChaingun", INT_MAX);
	TakeInventory("Chaingun", INT_MAX);
	TakeInventory("HRL", INT_MAX);
	TakeInventory("LandMineLayer", INT_MAX);
	TakeInventory("StrongholdRLauncher", INT_MAX);
	TakeInventory("RocketLauncher", INT_MAX);
	TakeInventory("Railgun", INT_MAX);
	TakeInventory("StunnerRifle", INT_MAX);
	TakeInventory("StrongholdPlasmaRifle", INT_MAX);
	TakeInventory("PlasmaRifle", INT_MAX);
	TakeInventory("StrongholdBFG9000", INT_MAX);
	TakeInventory("BFG9000", INT_MAX);
	TakeInventory("PyroCannon", INT_MAX);
	TakeInventory("Flamer", INT_MAX);
	TakeInventory("Devastator", INT_MAX);
	TakeInventory("Repeater", INT_MAX);
	TakeInventory("Pistol", INT_MAX);
	TakeInventory("StrongholdPistol", INT_MAX);
	TakeInventory("StrongholdFist", INT_MAX);
	TakeInventory("StrongholdShrinkFist", INT_MAX);
	TakeInventory("BruiserWeapon", INT_MAX);
	// Trackers (for SBARINFO)
	TakeInventory("JailTracker", INT_MAX);
	TakeInventory("JailTrackerAllPlayers", INT_MAX);
	TakeInventory("HUDCredits", INT_MAX);
	TakeInventory("ThrustDummy", INT_MAX);
	// Ammo
	TakeInventory("Clip", INT_MAX);
	TakeInventory("Cell", INT_MAX);
	TakeInventory("RocketAmmo", INT_MAX);
	TakeInventory("Gas", INT_MAX);
	TakeInventory("Shell", INT_MAX);
	TakeInventory("MineAmmo", INT_MAX);

	if (PlayersAreLate)
	{
		if(PrisonSpot)
		{
			Print(s:"You are late to the game!");
			GiveInventory("JailTracker", 1);
			UpdateJailTrackers();
			While(! Teleport_NoFog(PrisonSpot, true, 0))
				delay(5);
			GiveInventory("CoinItem", 1250);
			TakeInventory("LifeItem", 9);
		}
		else UpdateJailTrackers();
	}
	UpdateWaveTrackers();
	UpdateTime();

	// We need to reset the player's speed just in case he ended a map with it modified.
	// (The thrusting script can modify it.)
	SetActorProperty(0, APROP_Speed, 1.0);
	if(BriefActive)
		SetPlayerProperty (1, true, PROP_TOTALLYFROZEN);
	else
		SetPlayerProperty (0, false, PROP_TOTALLYFROZEN);
	delay(1);

	// Pause this script while Brief is active, so that way the player gets his gun
	// after it's finished. The Briefing scripts handle unfreezing the player.
	while(BriefNoGun)
		delay(1);

	if(GetLevelInfo(LEVELINFO_LEVELNUM)==999)
	{
		ACS_ExecuteAlways(S_HUD_COINS,0,0);
		GiveInventory("StrongholdShrinkFist",1);
		SetWeapon("StrongholdShrinkFist");
	//	GiveInventory("HUDCredits", 1);	// Enables intermission hud parts
		while(true)
		{
			delay(35);	// Placed at beginning of loop, so that there is no chance this
						// becomes a runaway script
			if(CheckActorClass(0,"StrongholdPlayer")&&!CheckWeapon("StrongholdShrinkFist"))
			{
				Print(s:"You're lucky you didn't get shot for holding a loaded weapon here!");
				restart;	// Clear inventory again
			}
		}
	}
	if(GameSkill()==SKILL_VERY_EASY||GameSkill()==SKILL_VERY_HARD)
		GiveInventory("Clip", 5);
	else
		GiveInventory("Clip", 30);
	GiveInventory("StrongholdFist", 1);
	GiveInventory("StrongholdPistol", 1);
	SetWeapon("StrongholdPistol");
}

script S_LATEPLAYERS OPEN
{
	delay(LatePlayersDelay);
	PlayersAreLate++;
}

// Displays amount of user's coins at top of screen in the intermap
script S_HUD_COINS (void)
{
	sethudsize(640,480,0);
	setfont("HUDINT");
	HudMessage(s:"a"; HUDMSG_PLAIN, MoneyBarHID, CR_UNTRANSLATED, 320.0, 240.0, 0.0);
	SetFont("SMALLFONT");
	int lastCoinAmount=-1;
	while(true)
	{
		if( CheckInventory("CoinItem") !=lastCoinAmount )
		{
			HudMessage(s:"\cGCredits\n$",i:CheckInventory("CoinItem");
				HUDMSG_PLAIN, MoneyCountHID, CR_UNTRANSLATED, 570.0, 30.0, 0.0);
			lastCoinAmount=CheckInventory("CoinItem");
		}
		delay(25);
	}
}

// If player has zero lives, alert him, then send to jail
// For if a player drops his last life while alive (respawn script handles spawning without a life)
script S_LIVE_WATCH ENTER
{
	// If the player has a JailTracker, then the respawn script is handling this, or he's in jail already
	if ((CheckInventory("LifeItem")==0) && (CheckInventory("JailTracker")==0) && (CheckInventory("Health") > 0))
	{
		if(PrisonSpot)
		{
			Print(s:"Warning: You are out of lives!\n\nYou are about to be teleported to jail");
			delay(35*6);	// Give the player a moment, so he can pick the life back
							// up if he accidentally dropped it.
			ACS_ExecuteAlways(S_RESPAWN, 0, 0);
		}
		else
		{
			Print(s:"Warning: You are out of lives!\n\nBut this map doesn't use a Jail, so you're free for now.");
			delay(20*35); // Wait a bit so that this message isn't constant
		}
	}
	delay(5);
	restart;
}

// Player loses a life
script 671 DEATH
{
	TakeInventory("ThrustDummy",1);
	if(GameActive&&GetLevelInfo(LEVELINFO_LEVELNUM)!=999)
		TakeInventory("LifeItem", 1);
}

script S_RESPAWN RESPAWN
{
	// Make sure our old dead body doesn't still have our tid
	Thing_ChangeTid(PLAYER_TID_START+PlayerNumber(),0);
	Thing_ChangeTid(0,PLAYER_TID_START+PlayerNumber());
	TakeInventory("JailTracker", INT_MAX);
	TakeInventory("ThrustDummy", 1);
	if (CheckInventory("LifeItem")==0)
	{
		if(PrisonSpot)
		{
			Print(s:"You are out of lives!");
			GiveInventory("JailTracker", 1);
			UpdateJailTrackers();
			While(! Teleport_NoFog(PrisonSpot, true, 0))
				delay(5);
		}
	}
	else
		UpdateJailTrackers();
	SetActorProperty(0,APROP_Speed,1.0);
	SetPlayerProperty(0,BriefActive,PROP_TOTALLYFROZEN);
}

script S_DISCONNECT (int gone) DISCONNECT
{
	UpdateJailTrackers();
}

function void SetJailTeleporter (bool setting)
{
	jailTeleporter=setting;
	if( jailTeleporter )
	{
		thing_deactivate(TeleporterOffLight);	// Dynamic Lights
		thing_activate(TeleporterOnLight);
		setlinetexture(PrisonTeleporterLineId, SIDE_FRONT, TEXTURE_MIDDLE, TeleporterOnTexture);
	}
	else
	{
		thing_activate(TeleporterOffLight);
		thing_deactivate(TeleporterOnLight);
		setlinetexture(PrisonTeleporterLineId, SIDE_FRONT, TEXTURE_MIDDLE, TeleporterOffTexture);
	}
}

script S_JAIL_LEAVE (int angle)
{
	if( jailTeleporter )
	{
		if( Teleport(PrisonExit, 0, 0) )
		{
			SetJailTeleporter( FALSE );
			TakeInventory("JailTracker", 1);
			GiveInventory("LifeItem", 1);
			UpdateJailTrackers();
		}
		else
		{
			ThrustThing(angle, 30, 0);
			Print(s:"Teleporter blocked, try again");
		}
	}
	else
	{
		ThrustThing(angle, 30, 0);
		Print(s:"Teleporter is off");
	}
}

script S_JAIL_GIVEUP (void)
{
	if(CheckInventory("JailTrackerAllPlayers")==PlayerCount())
		Exit_Normal(ExitPos);
	else
	{
		Print(s:"\cGThere are still \cCplayers \cGon the battlefield!");
		if(PrisonExitThrustAngle==-1)
			ACS_ExecuteAlways(S_G_THRUST,0,0);
		else
			ThrustThing(PrisonExitThrustAngle, 30, 0);
	}
}

script S_JAIL_OPEN (void) // This is the script called if you use a LifeItem
{
	// If the player is in jail, he can use his last LifeItem.
	// (...This is impossible to do without cheats.)
	if( (CheckInventory("LifeItem")==1) && (CheckInventory("JailTracker")==0) )
	{
		Print(s:"You can't use your last Life to open the jail teleporter!");
		SetResultValue( FALSE );
		Terminate;
	}
	if( PrisonTeleporterLineId )
	{
		if(CheckInventory("JailTrackerAllPlayers") > 0)
		{
			if( ! jailTeleporter )
			{
				PrintBold(s:"Prison Teleporter Opened");
				SetJailTeleporter( TRUE );
				SetResultValue( TRUE );
			}
			else
			{
				Print(s:"Prison Teleporter already Open");
				SetResultValue( FALSE );
			}
		}
		else
		{
			Print(s:"No players are in jail!");
			SetResultValue( FALSE );
		}
	}
	else
	{
		Print(s:"Not usable here!\n\nThis map does not have a jail teleporter to open.");
		SetResultValue( FALSE );
	}
}

script S_BRIEF_MAIN (void)
{
	ACS_Execute(S_BRIEF_ANIMATE,0,0);
	BriefActive=TRUE;
	BriefNoGun=TRUE;
	SetPlayerProperty (1, TRUE, PROP_TOTALLYFROZEN);
	SetFont("BLACK");
	SetHudSize(4,4,0);
	HudMessageBold (s:"a"; HUDMSG_PLAIN, FadeOutHID, CR_UNTRANSLATED,2.0, 2.0, 0.0);
	SetHudSize(640, 480, 0);
	SetFont(BriefBackground);
	HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefBGHID, 0, 320.0, 240.0, 0.0);
	SetHudSize(640, 480, 1);
	if(BriefSkippable)
	{
		SetFont("SMALLFONT");
		HudMessageBold(s:"\cCHit \cG<Use> \cCto skip the introduction";
			HUDMSG_FADEINOUT, BriefSkipHID, 0, 320.0, 465.0, 2.0, 6.0, 2.0);
	}
	if(BriefScript)
		ACS_ExecuteWait(BriefScript,0,0);
	ACS_Execute(S_BRIEF_END, 0, 0);
}

script S_BRIEF_ANIMATE (void)
{
	sethudsize(640, 480, 1);
	setfont("BIGFONT");
	hudmessagebold (s:"\cGInstructor Lt. Carmack:\n";HUDMSG_PLAIN, BriefNameHID, CR_UNTRANSLATED, 345.0, 310.0, 0.0);
	while( TRUE )
	{
		if (!BriefTalking)
		{
			setfont("BRIEFTN2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 0.0);
			delay(25);
			while(!BriefTalking)
				delay(1);
		}
		else
		{
			setfont("BRIEFTN2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTN2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY2");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
			setfont("BRIEFTY1");
			HudMessageBold (s:"a"; HUDMSG_PLAIN, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 2.0);
			delay(10);
		}
	}
}

script S_BRIEF_END (void)	// #251
{
	if(!BriefActive)
		terminate;
	ACS_Terminate(S_BRIEF_MAIN,0);
	ACS_Terminate(S_BRIEF_ANIMATE,0);
	if(BriefScript)
		ACS_Terminate(BriefScript,0);
	HudMessageBold(s:""; HUDMSG_PLAIN, BriefSkipHID, CR_UNTRANSLATED, 0.0, 0.0, 1.0); // Press use to skip
	HudMessageBold(s:""; HUDMSG_PLAIN, BriefExtraHID,	CR_UNTRANSLATED, 0.0, 0.0, 1.0); // Extra pictures
	HudMessageBold(s:""; HUDMSG_PLAIN, BriefHID,		CR_UNTRANSLATED, 0.0, 0.0, 1.0); // Message Text
	SetFont("BLACK");
	SetHudSize(4,4,0);
	HudMessageBold (s:"a"; HUDMSG_FADEOUT, FadeOutHID, CR_UNTRANSLATED,2.0, 2.0,0.0, 2.0);	// holdTime, outTime
	SetHudSize(640, 480, 0);
	SetFont(BriefBackground);
	HudMessageBold(s:"a"; HUDMSG_FADEOUT, BriefBGHID, 0, 320.0, 240.0, 0.0, 2.0);
	SetHudSize(640, 480, 1);
	SetFont("BIGFONT");
	HudMessageBold(s:"\cGInstructor Lt. Carmack:\n";
		HUDMSG_FADEOUT, BriefNameHID, CR_UNTRANSLATED, 345.0, 310.0, 0.0, 0.5);
	SetFont("BRIEFTN2");
	HudMessageBold (s:"a"; HUDMSG_FADEOUT, BriefTalkBoxHID, 0, BriefTalkBoxX, BriefTalkBoxY, 0.2, 0.5);
	Delay(1*35);
	BriefNoGun=FALSE;	// This lets the player spawn with his gun a bit before unfreezing
	Delay(2*35);
	BriefActive=FALSE;
	SetPlayerProperty (1, FALSE, PROP_TOTALLYFROZEN);
}

// Standard Battlefield Border Script
script S_BF_THRUST (int byte_angle, int focustid) // #254
{
	Print(s:"\cGYou must not leave the battlefield!");
//	ThrustThing(byte_angle, 30, 0, 0);
	ACS_ExecuteAlways(S_G_THRUST,0,focustid);
}

// Generic Thrust script, no angle needed
// Optional arg, focustid: Thrust is towards it
script S_G_THRUST (int focustid)
{
	if((LineSide()==LINE_FRONT) && (!CheckInventory("ThrustDummy")))
	{
		GiveInventory("ThrustDummy", 1);
		int oldx=GetActorX(0),oldy=GetActorY(0),oldz=GetActorZ(0),oldSpeed=GetActorProperty(0, APROP_Speed);
		SetActorProperty(0, APROP_Speed, 0.0);
		int byte_angle;
		if(!focustid)
		{
			delay(1);
			int newx=GetActorX(0),newy=GetActorY(0);
			// Gets angle of opposite of current momentum
			byte_angle=VectorAngle( oldx-newx, oldy-newy ) >> 8;
			SetActorPosition(0, oldx, oldy, oldz, false);
		}
		else
		{
			int focusx=GetActorX(focustid),focusy=GetActorY(focustid);
			byte_angle=VectorAngle( focusx-oldx, focusy-oldy ) >> 8;
		}
		Thing_Stop(0);
		int i;
		do
		{
			ThrustThing(byte_angle, max( min(i*3,30), 5), 0, 0);
			if( (i%10)==0)
			{
				if( i>35*13 )
					Thing_Damage(0,100000,MOD_UNKNOWN);
				else if( i>35*5 )
					Thing_Damage(0,20,MOD_UNKNOWN);
			}
			i++;
			delay(1);
		}
		while ( (CheckInventory("ThrustDummy")>0) && (GetActorProperty(0, APROP_Health)>0) );
			SetActorProperty(0, APROP_Speed, oldSpeed);
	}
	if(LineSide()==LINE_BACK)
		TakeInventory("ThrustDummy", 1);
}

// Does some sanity checks on the map
script S_DEBUG (int wavemanip /*void*/) // 'puke 930'
{
	if (wavemanip)
	{
		F_CallNextWave=wavemanip;
		terminate;
	}
	PrintBold(s:"Debug script starting");
	int i, j, count,errors;
	for(i=0; i<WeaponSpotsUsed; i++)
	{
		count=ThingCount(T_NONE, WeaponSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" weapon spots with tid ",d:WeaponSpots[i]);
	}
	for(i=0; i<MedicSpotsUsed; i++)
	{
		count=ThingCount(T_NONE, MedicSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" medic spots with tid ",d:MedicSpots[i]);
	}
	for(i=0; i<AmmoSpotsUsed; i++)
	{
		count=ThingCount(T_NONE, AmmoSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" ammo spots with tid ",d:AmmoSpots[i]);
	}
	for(i=0; i<PowerupSpotsUsed; i++)
	{
		count=ThingCount(T_NONE, PowerupSpots[i]);
		if(count !=1)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" powerup spots with tid ",d:PowerupSpots[i]);
	}
	for(i=0; i<ZoneDataUsed; i++)
	{
		for(j=8; j<=9; j++)
		{
			count=ThingCount(T_NONE, ZoneData[i][j]);
			if(count !=1)
				PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
					s:" zone mapspots with tid ",d:ZoneData[i][j]);
		}
	}
	// A mapspot with tid 900 or 901 used to be used as "TEST_TID" but is now useless.
	// Removing it helps remove some clutter.
	for(i=900; i<=901; i++)
	{
		count=ThingCount(T_NONE, i);
		if(count > 0)
			PrintBold(s:"Error ",d:++errors,s:": There are ",d:count,
				s:" extra mapspots with tid ",d:i);
	}
	if(PrisonSpot)
	{
		count=ThingCount(T_NONE, PrisonSpot);
		if(count < 8)
			PrintBold(s:"Error ",d:++errors,s:": There are only ",d:count,
				s:" prison spots, with tid ",d:PrisonSpot,s:". Suggested to have at least 8.");
		count=ThingCount(T_NONE, PrisonExit);
		if(!count)
			PrintBold(s:"Error ",d:++errors,s:": There is no PrisonExit with tid ",
				d:PrisonExit,s:". Required to have at least 1.");
		if(TeleporterOnLight)
		{
			count=ThingCount(T_NONE, TeleporterOnLight);
			if(count==0)
				PrintBold(s:"Error ",d:++errors,s:": There is no",
					s:" TeleporterOnLight, expecting tid ",d:TeleporterOnLight);
		}
		if(TeleporterOffLight)
		{
			count=ThingCount(T_NONE, TeleporterOffLight);
			if(count==0)
				PrintBold(s:"Error ",d:++errors,s:": There is no",
					s:" TeleporterOffLight, expecting tid ",d:TeleporterOffLight);
		}
	}
	// The HateEpicenter should be a shootable thing.
	// Can't directly check for that, so I check if the HateEpicenter is alive or is a HateTarget.
	if(HateEpicenter&&!( ClassifyActor(HateEpicenter) & ACTOR_ALIVE ) &&!GetActorProperty(HateEpicenter, APROP_Health))
		PrintBold(s:"Error ",d:++errors,s:": There is no",
			s:" HateTarget or living HateEpicenter, expecting tid ",d:HateEpicenter,
			s:".\nRemove the HateEpicenter line from the map's script if you don't want one.");
	if(BossMonster&&ThingCount(T_NONE,BossMonster) !=1 )
		PrintBold(s:"Error ",d:++errors,s:": There is more or less",s:" than 1 actor with the BossMonster Tid.");
	if(errors > 0)
		PrintBold(s:"Debug script completed, with ",d:errors,s:" error(s)\n\nCheck your console");
	else
		PrintBold(s:"Debug script completed with no errors");
}

// Randomizes the STR52 code if needed, and then prints the correct sequence to the screen.
script S_STR52CODEGET (void)	// Script 927
{
	// Has the code been set yet? Set a code if not
	if(!str52codeinit)
	{
		for(int i=0; i<5; i++)
			str52code[i]=random(0,9);
		str52codeinit=TRUE;
	}
	sethudsize(640,480,0);
	setFont("BigFont");
	HudMessage(d:str52code[0],s:" ",d:str52code[1],s:" ",d:str52code[2],s:" ",d:str52code[3],s:" ",d:str52code[4],s:" ";
		HUDMSG_PLAIN | HUDMSG_LOG, 11, CR_WHITE, 60.0, 400.0, 9.0);
	delay(35*8);
}

// HUD Stuff

script S_HUD OPEN clientside
{
	if(GetLevelInfo(LEVELINFO_LEVELNUM)==999)
		Terminate;
	// Launch a copy of the timer script clientside
	ACS_Execute( S_TIMER, 0, 0 );
	SetHudSize(640,480,1);
	int aspect, adjWidth, left, right,showedPar;
	while(true)
	{
		// If set, turn off hud, and wait for the value to be toggled again
		if(getcvar("sthd_hud_disable"))
		{
			ClearHud();
			while(getcvar("sthd_hud_disable"))
				delay(1);
		}
		// Code to disable HUD when regular HUD is gone
		/*if(getcvar("screenblocks")==12)
		{
			ClearHud();
			while(getcvar("screenblocks")==12)
				delay(1);
		}*/
		aspect=getaspectratio();
		adjWidth=aspect * 480;
		left=fround((640.0-adjWidth)/2);
		right=fround((adjWidth+640.0)/2);
		SetFont("HUDLEFT");
		HudMessageBold(s:"A"; HUDMSG_PLAIN, HUDLeftHID, CR_UNTRANSLATED,left+0.1, 0.1,0.0 );
		SetFont("HUDRIGHT");
		HudMessageBold(s:"A"; HUDMSG_PLAIN, HUDRightHID, CR_UNTRANSLATED,right+0.2, 0.1,0.0 );
		SetFont("BIGFONT");
		HudMessageBold (d:GetLevelInfo(LEVELINFO_LEVELNUM); HUDMSG_PLAIN, HUDLevelHID, CR_RED,left+83.0, 15.0,0.0 );
		// Show Par Time
		if(parTimeMode !=0)
		{
			// Time
			HudMessageBold (d:parTimeMinutes,s:":",s:parTimeSecondsSpace,d:parTimeSeconds;
				HUDMSG_PLAIN, HUDParTimeHID, CR_DARKGRAY,right-38.0, 80.0,0.0 );
			// Label
			if(parTimeMode==1)
				HudMessageBold (s:"Par Time";
					HUDMSG_PLAIN, HUDParTimeLabelHID, CR_DARKGRAY,right-70.0+0.2, 80.0,0.0 );
			else if (parTimeMode==2)
				HudMessageBold (s:"Best Time";
					HUDMSG_PLAIN, HUDParTimeLabelHID, CR_DARKGRAY,right-70.0+0.2, 80.0,0.0 );
		}
		else
		{
			HudMessageBold(s:""; HUDMSG_PLAIN, HUDParTimeHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
			HudMessageBold(s:""; HUDMSG_PLAIN, HUDParTimeLabelHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
		}
		showedPar=parTimeMode;
		do
		{
			// Wave
			HudMessageBold (d:curWave; HUDMSG_PLAIN, HUDWaveHID, CR_RED,left+192.0, 15.0,0.0 );
			// Body count
			HudMessageBold(d:GetLevelInfo(LEVELINFO_KILLED_MONSTERS); HUDMSG_PLAIN, HUDBodyCountHID, CR_RED,right-38.0, 39.0,0.0 );
			// Monsters left
			HudMessageBold (d:GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)-GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
				HUDMSG_PLAIN, HUDMonstersHID, CR_RED,left+180.0, 39.0,0.0 );
			// Time Spent
			HudMessageBold (d:levelMinutes,s:":",s:levelSecondsSpace,d:levelSeconds;
				HUDMSG_PLAIN, HUDTimeHID, CR_RED,right-38.0, 15.0,0.0 );
			delay(1);
		}
		while( (aspect==getaspectratio()) && (showedPar==parTimeMode) && (!getcvar("sthd_hud_disable")) /* && (getcvar("screenblocks")!=12) */ );
	}
}

function void clearHud (void)
{
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDLeftHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDRightHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDLevelHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDWaveHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDBodyCountHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDMonstersHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDTimeHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDParTimeHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
	HudMessageBold(s:""; HUDMSG_PLAIN, HUDParTimeLabelHID, CR_UNTRANSLATED, 0.0, 0.0, 0.5 );
}

script S_TIMER open
{
	if(MapScores[GetLevelInfo(LEVELINFO_LEVELNUM)]!=0)
		TimeAttackMode=TRUE;
	while( TRUE )
	{
		while( TimerIsLive )
		{
			delay( 1 );
			levelRunningTime++;
			if( levelRunningTime % 35==0 )
			{
				levelMinutes=(levelRunningTime/35)/60;
				levelSeconds=(levelRunningTime/35)%60;
				levelSecondsSpace=zerospace(levelSeconds,2);
			}
		}
		delay(1);
	}
}

function void StartTimer (void)
{
	TimerIsLive=TRUE;
	UpdateTime();
}

function void StopTimer (void)
{
	TimerIsLive=FALSE;
	UpdateTime();
}

function void UpdateWaveTrackers (void)
{
//	PrintBold(s:"UpdateWaveTrackers - Curwave=",d:Curwave);
	ACS_ExecuteAlways( S_SYNC, 0, SYNC_WAVE, Curwave);
}

// Time is tricky to update, because levelRunningTime is a 4 byte integer, and
// we can only send 3 bytes at a time in a script's arguments.
function void UpdateTime (void)
{
//	PrintBold(s:"UpdateTime - levelRunningTime=",d:levelRunningTime);
//	Scripts in reverse order because they'll probably be sent together in the same
//	packet, and executed backwards by clients.
	ACS_ExecuteAlways( S_SYNC, 0, SYNC_LOTIME | (TimerIsLive<<7),(levelRunningTime>>8)%256,levelRunningTime%256);
	ACS_ExecuteAlways( S_SYNC, 0, SYNC_HITIME,(levelRunningTime>>24),(levelRunningTime>>16)%256);
	// Maybe not the best place for sending the par time to clients, but it ensures no clients never get it
	if(parTimeMode !=0)
		ACS_ExecuteAlways( S_SYNC, 0, SYNC_PARTIME | ((parTimeMode-1)<<7),parTime>>8,parTime%256);
}

// Most significant byte first
function int unpack(int byte1, int byte2, int byte3, int byte4)
{
	return (byte1<<24) + (byte2<<16) + (byte3<<8) + byte4;
}

bool hiTimeBytesReady;
int hiTimeByte1, hiTimeByte2;

script S_SYNC (int flags, int byte1, int byte2) clientside
{
//	PrintBold(s:"S_SYNC: flags=",x:flags,s:", byte1=",d:byte1,s:", byte2=",d:byte2);
	if(AllVarsLocal)
		Terminate;
	switch(flags & 0x0000007f)
	{
		case SYNC_WAVE:
			curWave=byte1;
			break;
		case SYNC_HITIME:
			hiTimeByte1=byte1;
			hiTimeByte2=byte2;
			hiTimeBytesReady=TRUE;
			break;
		case SYNC_LOTIME:
			// Wait until SYNC_HITIME call has been made
			while( !hiTimeBytesReady )
				delay(1);
			hiTimeBytesReady=FALSE;
			levelRunningTime=unpack(hiTimeByte1, hiTimeByte2, byte1, byte2);
			TimerIsLive=(flags&0x00000080)>>7;
			break;
		case SYNC_PARTIME:
			setParTime( unpack(0,0,byte1,byte2), (flags&0x00000080)>>7 );
			break;
		default:
			PrintBold(s:"Error: S_SYNC called with invalid flags ",x:flags);
	}
}

// par in seconds, type=0 for "Par Time", type=1 for "Best Time"
function void setParTime (int par, int type)
{
	parTime=par;
	if ( parTime > 0 )
	{
		parTimeMode=type+1;
		parTimeMinutes=parTime / 60;
		parTimeSeconds=parTime % 60;
		parTimeSecondsSpace=zerospace(parTimeSeconds,2);
	}
	else
		parTimeMode=0;
}

script S_VAR_CHECK open
{
	AllVarsLocal=TRUE;
}